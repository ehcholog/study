## 목차
1. [웹과 네트워크의 기본에 대해 알아보자](#제1장-웹과-네트워크의-기본에-대해-알아보자)
2. [간단한 프로토콜 HTTP](#제2장-간단한-프로토콜-http)
3. [HTTP 정보는 HTTP 메시지에 있다](#제3장-http-정보는-http-메시지에-있다)
4. [결과를 전달하는 HTTP 상태 코드](#제4장-결과를-전달하는-http-상태-코드)
5. [HTTP와 연계하는 웹 서버](#제5장-http와-연계하는-웹-서버)
6. [HTTP 헤더](#제6장-http-헤더)
7. [웹을 안전하게 하는 HTTPS](#제7장-웹을-안전하게-하는-https)
8. [누가 액세스하고 있는지를 확인하는 인증](#제8장-누가-액세스하고-있는지를-확인하는-인증)
9. [HTTP에 기능을 추가한 프로토콜](#제9장-http에-기능을-추가한-프로토콜)
10. [웹 콘텐츠에서 사용하는 기술](#제10장-웹-콘텐츠에서-사용하는-기술)
11. [웹 공격 기술](#제11장-웹-공격-기술)

## 제1장. 웹과 네트워크의 기본에 대해 알아보자
### 1.1 웹은 HTTP로 나타낸다
웹 브라우저 주소 입력란에 URL을 입력했을 때 웹 페이지가 보여지는 과정 :

1. 브라우저 주소 입력란에 URL을 입력하여 어딘가에 송신
2. 어딘가에서 응답이 돌아오면 웹 페이지가 표시됨  
=> 아무것도 없는데 웹 페이지가 표시될 수는 없고, 웹 브라우저가 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일 등의 정보를 얻어서 표시하는 것. 이때 서버에 의뢰를 하는 웹 브라우저 등을 **클라이언트(Client)** 라고 부름.

클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 **HTTP(HyperText Transfer Protocol)** 이라 불리는 **프로토콜**이다. 프로토콜이라는 의미는 "약속"이며, 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.

### 1.2 HTTP는 이렇게 태어났고 성장했다
#### 1.2.1 웹은 지식공유를 위해 고안되었다.
HTTP는 1989년 3월 CERN(유럽 입자 물리학 연구소)의 팀 버너스 리 박사가 멀리 떨어져 있는 동료 연구자와 지식을 공용하게 할 수 있도록 시스템을 고안하여 탄생하였다. 최초로 고안한 것은 여러 문서를 상호간에 관련 짓는 **하이퍼텍스트(HyperText)** 에 의해 상호간에 참조할 수 있는 **WWW(World Wide Web)** 의 기본 개념이 되는 것이었다.

WWW를 구성하는 기술로서, 문서 기술 언어로는 SGML을 베이로서 한 **HTML(HyperText Markup Language)**, 문서 전송 프로토콜로는 **HTTP**, 문서의 주소를 지정하는 방법으로 **URL(Uniform Resource Locator)** 등 세 가지가 제안되었다.

이러한 일련의 시스템(구조)의 명칭을 **WWW** 혹은 **웹(Web)** 이라 부른다.

#### 1.2.2 웹이 성장한 시대
1990년 11월 CERN에서 세계 최초의 웹 서버와 웹 브라우저가 개발되었고, 대한민국 최초의 홈페이지는 그로부터 3년 뒤인 1993년에 개발되었다.

1990년에는 HTML 1.0 초안도 검토되었지만 애매한 부분이 많았기 때문에 초안인 상태로 폐기 되었다.

1993년 1월에는 NCSA(미국 수퍼 컴퓨터 응용 연구소)에서 현재 사용하는 웹 브라우저의 선조라고 말할 수 있는 모자이크(Mosaic)를 개발했고, 같은 해 가을에 윈도우 판과 매킨토시 판도 개발되었다.

1995년에는 마이크로소프트(Microsoft) 사에서 인터넷 익스플로러(Internet Explorer) 1.0과 2.0을 출시했다. 이 무렵에 현재 웹 서버 표준의 하나인 아파치(Apache)도 Apache 0.2로 등장했다.

2004년에는 모질라 파이어폭스(Mozilla Firefox)가 출시되었고, 그 후 크롬(Chrome)과 오페라(Opera), 사파리(Safari)와 같은 브라우저들이 등장하여 점차 점유율을 늘려갔다.

#### 1.2.3 진보 안하는 HTTP
**HTTP/0.9**  
HTTP가 등장한 때는 1990년인데, 당시 정식 사양서는 아니었다. 이 당시 등장한 HTTP는 1.0 이전이라는 의미에서 HTTP/0.9로 불린다.

**HTTP/1.0**  
1996년 5월 HTTP가 정식 사양으로 공개되었다. 초기의 사양이지만 현재에서 아직 많은 서버 상에서 현역으로 가동되고 있는 프로토콜 사양이다.

**HTTP/1.1**  
1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전이다.

HTTP는 등장 당시 주로 텍스트를 전송하기 위한 프로토콜이었지만 여러 가지 기능이 계속 추가되어 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.

### 1.3 네트워크의 기본은 TCP/IP
#### 1.3.1 TCP/IP는 프로토콜의 집합
컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신해야 하는데 이때 필요한 규칙이 프로토콜이다. TCP/IP란 **인터넷에 관련된 다양한 프로토콜 집합의 총칭**이다.

#### 1.3.2 계층으로 관리하는 TCP/IP
TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층' 이렇게 4계층으로 나뉘어 있다.

프로토콜이 계층화되어 있으면 변경이 생겼을 때 해당 계층만 바꾸면 되고 설계 시 편리하다는 장점이 있다.

**애플리케이션 계층**  
유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정. FTP, DNS, HTTP 등이 있다.

**트랜스포트 계층**  
애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공. TCP(Transmission Control Protocol)와 UDP(User Data Protocol)이 있다.

**네트워크 계층**  
네트워크 상에서 패킷의 이동을 다룸. 패킷이란 전송하는 데이터의 최소 단위이며, 이 계층에서는 어떠한 경로(절차)를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 한다.

**링크 계층**  
네트워크에 접속하는 하드웨어적인 면을 다룸. 디바이스 드라이버랑 네트워크 인터페이스 카드(NIC)를 포함하며, 케이블과 같이 물리적으로 보이는 하드웨어적 측면은 모두 링크 계층의 역할이다.

#### 1.3.3 TCP/IP 통신의 흐름
TCP/IP로 통신을 할 때에는 계층을 순서대로 거쳐 통신을 한다. 송신하는 측은 애플리케이션 계층에서부터 내려가고, 수신하는 측은 애플리케이션 계층으로 올라간다.

클라이언트 : HTTP 클라이언트(애플리케이션 계층) -> TCP(트랜스포트 계층) -> IP(네트워크 계층) -> 네트워크(링크 계층)  
서버 : 네트워크(링크 계층) -> IP(네트워크 계층) -> TCP(트랜스포트 계층) -> HTTP 서버(애플리케이션 계층)

송신측에서는 각 계층을 거칠 때마다 헤더로 불려지는 정보를 추가하며, 수신측에서는 각 계층을 거칠 때마다 해당 계층의 헤더를 삭제한다. 이렇게 정보를 감싸는 것을 **캡슐화**라고 한다.

### 1.4 HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS
#### 1.4.1 배송을 담당하는 IP
IP는 개개의 패킷을 상대방에게 전달한다. 상대방에게 전달하려면 여러 요소가 필요한데, 그 중에는 IP 주소와 MAC 주소가 있다. IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이며, IP 주소는 변경 가능하지만 MAC 주소는 변경할 수 없다.

IP 통신은 MAC 주소에 의존해서 통신하는데, 이때 ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다. ARP는 주소를 해결하기 위한 프로토콜 중 하나로, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.

#### 1.4.2 신뢰성을 담당하는 TCP
TCP는 트랜스포트 계층으로서 신뢰성 있는 바이트 스트림 서비스를 제공한다. **바이트 스트림 서비스**란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말하며, 결국 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인한다.

상대에게 확실하게 데이터를 보내기 위해서 TCP는 **쓰리웨이 핸드셰이킹(three way handshaking)** 이라는 방법을 사용한다. 이 방법은 패킷을 보내고 끝내는 것이 아니라 보내졌는지 여부를 상대에게 확인한다.

1. 송신측에서 최초 'SYN' 플래그로 상대에게 접속함과 동시에 패킷을 보냄.
2. 수신측에서 'SYN/ACK' 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전함.
3. 마지막으로 송신측이 'ACK' 플래그를 보내 패킷 교환이 완료되었음을 전함.

이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 그와 동시에 같은 수순으로 패킷을 재전송한다.

### 1.5 이름 해결을 담당하는 DNS
DNS(Domain Name System)는 HTTP와 같이 응용 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. 사람에게 친숙한 도메인명에서 숫자로 되어있는 IP 주소를 조사하거나 반대로 IP 주소로부터 도메인명을 조사하는 서비스를 제공하고 있다.

### 1.6 각각과 HTTP와의 관계
1. 클라이언트가 DNS에 도메인명으로 요청한 IP 주소를 제공 받음.
2. HTTP 담당 : 웹 서버에 보낼 HTTP 메시지 작성.
3. TCP 담당 : 통신하기 쉽도록 HTTP 메시지를 패킷으로 분해.
4. IP 담당 : 상대가 어디에 있는지 찾아 중계해 가면서 배송.
5. TCP 담당 : 상대방으로부터 패킷을 수신.
6. HTTP 담당 : 웹 서버에 대한 리퀘스트 내용을 처리.
7. 서버에서 처리 결과를 마찬가지로 TCP/IP 통신 순서대로 클라이언트에 반환.

### 1.7 URI와 URL
#### 1.7.1 URI는 리소스 식별자
**URI(Uniform Resource Identifiers)**  
**Uniform** : 통일된 서식을 결정하는 것으로, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할 수 있게 한다. 또한, 새로운 스키마(http: 와 ftp 등) 도입을 용이하게 한다.

**Resource** : '식별 가능한 모든 것'으로서 도큐먼트 파일뿐만 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것은 모두 리소스이다. 리소스는 단일한 부분만 아니라 복수의 집합도 리소스로 파악할 수 있다.

**Identifier** : 식별 가능한 것을 참조하는 오브젝트이며 식별자로 불린다. 결국, URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자이다. **스키마**는 리소스를 얻기 위한 수단에 이름을 붙이는 방법이다.

#### 1.7.2 URL 포맷
URI는 필요한 정보 전체를 지정하는 완전 수식 절대 URI 혹은 완전 수식 절대 URL과 브라우저 중의 기준 URI에서 상대적 위치를 지정하는 상대 URI이 있다.

http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1

스키마 : http://  
자격정보(크리덴셜) : user:pass  
서버주소 : www.example.jp  
서버포트 : 80  
계층적 파일 패스 : dir/index.html  
쿼리 문자열 : uid=1  
프래그먼트 식별자 : ch1

## 제2장. 간단한 프로토콜 HTTP
### 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다
TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 한다. 리소스를 요구하는 쪽이 **클라이언트**가 되고, 리소스를 제공하는 쪽이 **서버**가 된다.

### 2.2 리퀘스트와 리스폰스를 교환하여 성립
HTTP는 클라이언트로부터 리퀘스트(요청, Request)가 송신되며, 그 결과가 서버로부터 리스폰스(응답, Response)로 되돌아온다.  

리퀘스트는 다음과 같이 구성된다.

GET /index.html  
HTTP /1.1  Host: www.hackr.jp

"GET"은 서버에 요구하는 종류를 나타내며 메소드라고 불린다. "/index.html"은 요구 대상인 리소스이며 리퀘스트 URI라고 한다. "HTTP /1.1"은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호이다.

리스폰스는 다음과 같이 구성된다.

HTTP /1.1 200 OK  
Date: Tue, 10 Jul 2012 06:50:15 GMT  
Content-Length: 362  
Content-Type: text/html  

html  
...

첫번째 줄에는 리퀘스트와 같이 서버의 HTTP 버전을 나타내고 있고, "200 OK"는 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명이다. 다음 줄은 리스폰스가 발생한 일시를 나타내는 헤더 필드의 정보들이 있다. 그리고 빈 줄로 구분한 아래 부분에 있는 부분이 바디(body)라고 불리는 리소스 본체이다.

### 2.3 HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜이다. 즉, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해 기억하지 않는다. 이는 많은 데이터를 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위함이다. 상태를 계속 유지하기 위한 기술로는 **쿠키(Cookie)** 가 있다.

### 2.4 리퀘스트 URI로 리소스를 식별
클라이언트는 리소스를 호출할 때마다 리퀘스트를 송신할 때 리퀘스트 URI라고 불리는 형식을 포함해야 할 필요가 있다. 리퀘스트 URI를 지정하는 방법에는 여러 종류가 있다.
1. 모든 URI를 리퀘스트 URI에 포함한다. 예) GEP http://hackr.jp/index.html HTTP/ 1.1
2. Host 헤더 필드에 네트워크 로케이션을 포함한다. 예) GET /index.html HTTP/ 1.1 Host: hackr.jp

특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는 리퀘스트 URI에 [*]을 지정할 수 있다. 예) OPTIONS * HTTP/1.1

### 2.5 서버에 임무를 부여하는 HTTP 메소드
**GET : 리소스 획득**  
GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다.

**POST : 엔티티 전송**  
GET으로도 엔티티를 전송할 수 있지만, 일반적으로는 POST를 사용한다.

**PUT : 파일 전송**  
PUT 메소드는 파일을 전송하기 위해서 사용된다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다. 그러나 HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 RESP(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있다.

**HEAD : 메시지 헤더 획득**  
GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.

**DELETE : 파일 삭제**  
DELETE 메소드는 PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. PUT 메소드와 마찬가지로 HTTP /1.1의 DELETE 자체에는 인증 기능이 없기 때문에 PUT과 비슷한 경우에 사용된다.

**OPTIONS : 제공하고 있는 메소드의 문의**  
OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.

**TRACE : 경로 조사**  
TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 클라이언트는 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다. TRACE 메소드는 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않는다.

**CONNECT : 프록시에 터널링 요구**  
CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL이랑 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해서 사용되고 있다.

### 2.6 메소드를 사용해서 지시를 내리다
리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라고 불리는 명령이 있다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재하며, GET과 POST, HEAD 등이 있다. 메소드는 대문자와 소문자를 구별하기 때문에 대문자로 기재할 필요가 있다.

### 2.7 지속 연결로 접속량을 절약
#### 2.7.1 지속 연결
HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해 **지속 연결(Persistent Connections)** 이라는 방법을 고안하였다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다는 것이다. 지속 연결의 이점은 TCP 커넥션의 연결과 종료의 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감되고, 오버헤드를 줄인 만큼 HTTP 통신이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다.

#### 2.7.2 파이프라인화
지속 연결은 여러 리퀘스트를 보낼 수 있도록 **파이프라인(HTTP pipelining)화**를 가능하게 한다. 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.

### 2.8 쿠키를 이용한 상태 관리
HTTP는 스테이트리스(stateless) 프로토콜이기 때문에 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않는다. 예를 들면, 인증한 웹 페이지에서 상태 관리를 하지 않는다면 새로운 페이지로 이동할 때마다 매번 인증을 해야 한다. 이러한 문제를 해결하기 위한 것이 쿠키이다.

쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 클라이언트에 보존하게 된다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신하면 서버는 클라이언트가 보내온 쿠키를 확인해 어느 클라이언트가 접속했는지 체크해서 이전 상태를 알 수 있다.

## 제3장. HTTP 정보는 HTTP 메시지에 있다
### 3.1 HTTP 메시지
HTTP 메시지는 복수 행의 데이터로 구성된 텍스트 문자열이다. HTTP 메시지는 크게 메시지 헤더와 메시지 바디로 구성되며, 최초에 나타나는 개행 문자로 헤더와 바디를 구분한다. 항상 메시지 바디가 존재하지는 않는다.

### 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조
**리퀘스트 라인**  
리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함

**상태 라인**  
리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함

**헤더 필드**  
리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함. 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드의 4종류

**그 외**  
HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우

### 3.3 인코딩으로 전송 효율을 높이다
전송할 때 인코딩을 하면 다량의 액세스를 효율 좋게 처리할 수 있지만 컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다.

#### 3.3.1 메시지 바디와 엔티티 바디의 차이
**메시지(message)**  
HTTP 통신의 기본 단위로 **옥텟 시퀀스(Octet sequence, octet은 8비트)** 로 구성되고 통신을 통해서 전송된다.

**엔티티(entity)**  
리퀘스트랑 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다.

#### 3.3.2 압축해서 보내는 콘텐츠 코딩
콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한 채 zip 등으로 압축해서 송신한다.

#### 3.3.3 분해해서 보내는 청크 전송 코딩
HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시하는 기능을 **청크 전송 코딩(Chunked transfer Coding)** 이라고 한다.

### 3.4 여러 데이터를 보내는 멀티파트
메일의 경우 본문 텍스트나 복수의 첨부 파일 등을 붙여서 함께 보낼 수 있는데, 이것은 **MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)** 으로 불리는 기능을 사용한다. MIME는 이미지 등의 바이너리 데이터를 아스키(ASCII) 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있는데, 이 MIME의 확장 사양에 있는 멀티파트라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있다. HTTP도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다.

멀티파트에는 다음과 같은 것들이 있다.  
multipart/form-data : Web 폼으로부터 파일 업로드에 사용  
multipart/byteranges : 상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용

HTTP 메시지로 멀티파트를 사용할 때에는 Content-type 헤더 필드를 사용하며, 각각의 엔티티를 구분하기 위해 "boundary" 문자열을 사용한다. 각 엔티티의 처음과 끝에 "--"를 삽입한다. (예 : "--AaB03x--")

### 3.5 일부분만 받는 레인지 리퀘스트
다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 해야한다. 이러한 문제를 해결하기 위해 **리줌(resume)** 이라는 기능이 필요하게 되었다. 이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 이와 같이 범위를 지정하여 리퀘스트 하는 것을 **레인지 리퀘스트(Range Request)** 라고 한다.

레인지 리퀘스트를 할 때에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다.

5,001 ~ 10,000 바이트  
`Range: bytes=5001-10000`

5,001 바이트 이상  
`Range: bytes=5001-`

처음부터 3,000 바이트까지, 그리고 5,000 ~ 7,000 바이트까지의 복수 범위  
`Range: bytes=-3000,5000-7000`

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content 라는 리스폰스 메시지가 되돌아온다. 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 되돌아온다. 서버가 레인지 리퀘스트를 지원하지 않는 경우에는 상태 코드 200 OK 라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다.

### 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
내용은 같지만 영어판과 한국어판과 같이 표시되는 언어가 다른 웹 페이지와 같은 구조를 **콘텐츠 네고시에이션(Content Negotiation)** 이라고 한다. 콘텐츠 네고시에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것이다. 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다.

콘텐츠 네고시에이션에는 다음과 같은 종류들이 있다.

**서버 구동형 네고시에이션(Server-driven Negotiation)**  
서버 측에서 콘텐츠 네고시에이션을 하는 방식이다. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다. 단지, 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고는 할 수 없다.

**에이전트 구동형 네고시에이션(Agent-driven Negotiation)**  
클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식이다. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다. JavaScript 등으로 웹 페이지에서 자동적으로 정하는 것도 있다. 예를 들면, OS의 종류나 브라우저의 종류 등에 의해서 PC용과 스마트폰용 웹 페이지를 자동으로 전환하는 것이 이에 해당한다.

**트랜스페어런트 네고시에이션(Transparent Negotiation)**  
서버 구동형과 에이전트 구동형을 혼합한 것이다.

## 제4장. 결과를 전달하는 HTTP 상태 코드
### 4.1 상태 코드는 서버로부터 리퀘스트 결과를 전달한다
상태 코드는 3자리 숫자와 설명으로 나타내는데 첫 번째 자리는 리스폰스의 클래스를 의미하며, 다음과 같이 5개가 정의되어 있다.

**1xx (Informational 클래스)** : 리퀘스트를 받아들여 처리중  
**2xx (Success 클래스)** : 리퀘스트를 정상적으로 처리했음  
**3xx (Redirection 클래스)** : 리퀘스트를 완료하기 위해서 추가 동작이 필요  
**4xx (Client Error 클래스)** : 서버는 리퀘스트 이해 불가능  
**5xx (Server Error 클래스)** : 서버는 리퀘스트 처리 실패

### 4.2 2xx 성공(Success)
2xx 리스폰스는 리퀘스트가 정상으로 처리되었음을 나타낸다.

#### 4.2.1 200 OK
클라이언트가 보낸 리퀘스트를 서버가 정상 처리하였음을 나타낸다.

#### 4.2.2 204 No Content
서버가 리퀘스트를 받아서 처리하는 데는 성공했지만 리스폰스에 엔티티 바디를 포함하지 않는다. 클라이언트에 새로운 정보를 보낼 필요가 없는 경우이다.

#### 4.2.3 206 Partial Content
Range에 의해서 범위가 지정된 리퀘스트에 의해서 서버가 부분적 GET 리퀘스트를 받았음을 나타낸다. 리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함된다.

### 4.3 3xx 리다이렉트(Redirection)
3xx 리스폰스는 리퀘스트가 정상적으로 처리를 종료하기 위해 브라우저 측에서 특별한 처리를 수행해야 함을 나타낸다.

#### 4.3.1 301 Moved Permanently
리퀘스트 된 리소스에는 새로운 URI가 부여되어 있기 때문에 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것을 나타낸다. 디렉토리를 지정했을 때 마지막 부분에 슬래시(/)를 붙이는 것을 잊을 경우 등이다.  
`http://example.com/sample`

#### 4.3.2 302 Found
리퀘스트 된 리소스에는 새로운 URI가 할당되어 있기 때문에 그 URI를 참조해 주길 바란다는 의미를 나타낸다. 301 Moved Permanently와 비슷하지만 302의 경우에는 영구적인 이동이 아닌 일시적인 것이다.

#### 4.3.3 303 See Other
리퀘스트에 대한 리소스는 다른 URI에 있기 때문에 GET 메소드를 사용해야 얻어햐 한다는 의미이다. 이것은 302 Found와 같은 기능이지만 리다이렉트 장소를 GET 메소드로 얻어야 한다고 명확하게 되어있는 점이 다르다. 예를 들면, POST 메소드로 액세스한 CGI 프로그램을 실행한 후에 처리 결과를 별도의 URI에 GET 메소드로 리다이렉트 시키고 싶은 경우 등에 303이 사용된다. 302 Found 라도 같은 일이 가능하지만 303을 사용하는 것이 바람직하다.

#### 4.3.4 304 Not Modified
클라이언트가 조건부 리퀘스트를 했을 때 리소스에 대한 액세스는 허락하지만 조건이 충족되지 않음을 표시한다. 304를 되돌려 줄 경우에는 리스폰스 바디에 어떤 것도 포함되면 안된다. 304는 3xx에 분류되어 있지만 리다이렉트와는 관계가 없다.

#### 4.3.5 307 Temporary Redirect
302 Found와 같은 의미를 지니지만 302의 경우에는 POST로부터 GET으로 치환이 금지되어 있는데도 불구하고 구현상 그와 같이 되어 있지는 않다. 307에서는 브라우저 사양에 따라 POST에서 GET으로 치환을 하지 않는다.

### 4.4 4xx 클라이언트 에러(Client Error)
4xx 리스폰스는 클라이언트의 원인으로 에러가 발생했음을 나타낸다.

#### 4.4.1 400 Bad Request
리퀘스트 구문이 잘못되었음을 나타낸다. 브라우저는 이것을 200 OK와 같이 취급한다.

#### 4.4.2 401 Unauthorized
송신한 리퀘스트에 HTTP 인증 정보가 필요하다는 것을 나타낸다. 이미 1번 리퀘스트가 이루어진 경우에는 유저 인증에 실패했음을 표시한다.

#### 4.4.3 403 Forbidden
리퀘스트 된 리소스의 액세스가 거부되었음을 나타낸다. 403이 발생한 원인으로는 파일 시스템의 퍼미션이 부여되지 않은 경우와 액세스 권한에 문제가 있는 것 등이 있다.

#### 4.4.4 404 Not Found
리퀘스트한 리소스가 서버상에 없다는 것을 나타낸다. 서버 측에 해당 리퀘스트를 거부하고 싶은 이유를 분명히 하고 싶지 않은 경우에도 해당된다.

### 4.5 서버 에러(Server Error)
5xx 리스폰스는 서버 원인으로 에러가 발생하고 있음을 나타낸다.

#### 4.5.1 500 Internal Server Error
서버에서 리퀘스트를 처리하는 도중에 에러가 발생하였음을 나타낸다. 웹 애플리케이션 에러가 발생한 경우나 일시적인 경우도 있다.

#### 4.5.2 503 Serveice Unavaliable
일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음을 나타내고 있다.

## 제5장. HTTP와 연계하는 웹 서버

## 제6장. HTTP 헤더

## 제7장. 웹을 안전하게 하는 HTTPS

## 제8장. 누가 액세스하고 있는지를 확인하는 인증

## 제9장. HTTP에 기능을 추가한 프로토콜

## 제10장. 웹 콘텐츠에서 사용하는 기술

## 제11장. 웹 공격 기술
