## 목차
1. [웹과 네트워크의 기본에 대해 알아보자](#제1장-웹과-네트워크의-기본에-대해-알아보자)
2. [간단한 프로토콜 HTTP](#제2장-간단한-프로토콜-http)
3. [HTTP 정보는 HTTP 메시지에 있다](#제3장-http-정보는-http-메시지에-있다)
4. [결과를 전달하는 HTTP 상태 코드](#제4장-결과를-전달하는-http-상태-코드)
5. [HTTP와 연계하는 웹 서버](#제5장-http와-연계하는-웹-서버)
6. [HTTP 헤더](#제6장-http-헤더)
7. [웹을 안전하게 하는 HTTPS](#제7장-웹을-안전하게-하는-https)
8. [누가 액세스하고 있는지를 확인하는 인증](#제8장-누가-액세스하고-있는지를-확인하는-인증)
9. [HTTP에 기능을 추가한 프로토콜](#제9장-http에-기능을-추가한-프로토콜)
10. [웹 콘텐츠에서 사용하는 기술](#제10장-웹-콘텐츠에서-사용하는-기술)
11. [웹 공격 기술](#제11장-웹-공격-기술)

## 제1장. 웹과 네트워크의 기본에 대해 알아보자
### 1.1 웹은 HTTP로 나타낸다
웹 브라우저 주소 입력란에 URL을 입력했을 때 웹 페이지가 보여지는 과정 :

1. 브라우저 주소 입력란에 URL을 입력하여 어딘가에 송신
2. 어딘가에서 응답이 돌아오면 웹 페이지가 표시됨  
=> 아무것도 없는데 웹 페이지가 표시될 수는 없고, 웹 브라우저가 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일 등의 정보를 얻어서 표시하는 것. 이때 서버에 의뢰를 하는 웹 브라우저 등을 **클라이언트(Client)** 라고 부름.

클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 **HTTP(HyperText Transfer Protocol)** 이라 불리는 **프로토콜**이다. 프로토콜이라는 의미는 "약속"이며, 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.

### 1.2 HTTP는 이렇게 태어났고 성장했다
#### 1.2.1 웹은 지식공유를 위해 고안되었다.
HTTP는 1989년 3월 CERN(유럽 입자 물리학 연구소)의 팀 버너스 리 박사가 멀리 떨어져 있는 동료 연구자와 지식을 공용하게 할 수 있도록 시스템을 고안하여 탄생하였다. 최초로 고안한 것은 여러 문서를 상호간에 관련 짓는 **하이퍼텍스트(HyperText)** 에 의해 상호간에 참조할 수 있는 **WWW(World Wide Web)** 의 기본 개념이 되는 것이었다.

WWW를 구성하는 기술로서, 문서 기술 언어로는 SGML을 베이로서 한 **HTML(HyperText Markup Language)**, 문서 전송 프로토콜로는 **HTTP**, 문서의 주소를 지정하는 방법으로 **URL(Uniform Resource Locator)** 등 세 가지가 제안되었다.

이러한 일련의 시스템(구조)의 명칭을 **WWW** 혹은 **웹(Web)** 이라 부른다.

#### 1.2.2 웹이 성장한 시대
1990년 11월 CERN에서 세계 최초의 웹 서버와 웹 브라우저가 개발되었고, 대한민국 최초의 홈페이지는 그로부터 3년 뒤인 1993년에 개발되었다.

1990년에는 HTML 1.0 초안도 검토되었지만 애매한 부분이 많았기 때문에 초안인 상태로 폐기 되었다.

1993년 1월에는 NCSA(미국 수퍼 컴퓨터 응용 연구소)에서 현재 사용하는 웹 브라우저의 선조라고 말할 수 있는 모자이크(Mosaic)를 개발했고, 같은 해 가을에 윈도우 판과 매킨토시 판도 개발되었다.

1995년에는 마이크로소프트(Microsoft) 사에서 인터넷 익스플로러(Internet Explorer) 1.0과 2.0을 출시했다. 이 무렵에 현재 웹 서버 표준의 하나인 아파치(Apache)도 Apache 0.2로 등장했다.

2004년에는 모질라 파이어폭스(Mozilla Firefox)가 출시되었고, 그 후 크롬(Chrome)과 오페라(Opera), 사파리(Safari)와 같은 브라우저들이 등장하여 점차 점유율을 늘려갔다.

#### 1.2.3 진보 안하는 HTTP
**HTTP/0.9**  
HTTP가 등장한 때는 1990년인데, 당시 정식 사양서는 아니었다. 이 당시 등장한 HTTP는 1.0 이전이라는 의미에서 HTTP/0.9로 불린다.

**HTTP/1.0**  
1996년 5월 HTTP가 정식 사양으로 공개되었다. 초기의 사양이지만 현재에서 아직 많은 서버 상에서 현역으로 가동되고 있는 프로토콜 사양이다.

**HTTP/1.1**  
1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전이다.

HTTP는 등장 당시 주로 텍스트를 전송하기 위한 프로토콜이었지만 여러 가지 기능이 계속 추가되어 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.

### 1.3 네트워크의 기본은 TCP/IP
#### 1.3.1 TCP/IP는 프로토콜의 집합
컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신해야 하는데 이때 필요한 규칙이 프로토콜이다. TCP/IP란 **인터넷에 관련된 다양한 프로토콜 집합의 총칭**이다.

#### 1.3.2 계층으로 관리하는 TCP/IP
TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층' 이렇게 4계층으로 나뉘어 있다.

프로토콜이 계층화되어 있으면 변경이 생겼을 때 해당 계층만 바꾸면 되고 설계 시 편리하다는 장점이 있다.

**애플리케이션 계층**  
유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정. FTP, DNS, HTTP 등이 있다.

**트랜스포트 계층**  
애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공. TCP(Transmission Control Protocol)와 UDP(User Data Protocol)이 있다.

**네트워크 계층**  
네트워크 상에서 패킷의 이동을 다룸. 패킷이란 전송하는 데이터의 최소 단위이며, 이 계층에서는 어떠한 경로(절차)를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 한다.

**링크 계층**  
네트워크에 접속하는 하드웨어적인 면을 다룸. 디바이스 드라이버랑 네트워크 인터페이스 카드(NIC)를 포함하며, 케이블과 같이 물리적으로 보이는 하드웨어적 측면은 모두 링크 계층의 역할이다.

#### 1.3.3 TCP/IP 통신의 흐름
TCP/IP로 통신을 할 때에는 계층을 순서대로 거쳐 통신을 한다. 송신하는 측은 애플리케이션 계층에서부터 내려가고, 수신하는 측은 애플리케이션 계층으로 올라간다.

클라이언트 : HTTP 클라이언트(애플리케이션 계층) -> TCP(트랜스포트 계층) -> IP(네트워크 계층) -> 네트워크(링크 계층)  
서버 : 네트워크(링크 계층) -> IP(네트워크 계층) -> TCP(트랜스포트 계층) -> HTTP 서버(애플리케이션 계층)

송신측에서는 각 계층을 거칠 때마다 헤더로 불려지는 정보를 추가하며, 수신측에서는 각 계층을 거칠 때마다 해당 계층의 헤더를 삭제한다. 이렇게 정보를 감싸는 것을 **캡슐화**라고 한다.

### 1.4 HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS
#### 1.4.1 배송을 담당하는 IP
IP는 개개의 패킷을 상대방에게 전달한다. 상대방에게 전달하려면 여러 요소가 필요한데, 그 중에는 IP 주소와 MAC 주소가 있다. IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이며, IP 주소는 변경 가능하지만 MAC 주소는 변경할 수 없다.

IP 통신은 MAC 주소에 의존해서 통신하는데, 이때 ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다. ARP는 주소를 해결하기 위한 프로토콜 중 하나로, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.

#### 1.4.2 신뢰성을 담당하는 TCP
TCP는 트랜스포트 계층으로서 신뢰성 있는 바이트 스트림 서비스를 제공한다. **바이트 스트림 서비스**란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말하며, 결국 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인한다.

상대에게 확실하게 데이터를 보내기 위해서 TCP는 **쓰리웨이 핸드셰이킹(three way handshaking)** 이라는 방법을 사용한다. 이 방법은 패킷을 보내고 끝내는 것이 아니라 보내졌는지 여부를 상대에게 확인한다.

1. 송신측에서 최초 'SYN' 플래그로 상대에게 접속함과 동시에 패킷을 보냄.
2. 수신측에서 'SYN/ACK' 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전함.
3. 마지막으로 송신측이 'ACK' 플래그를 보내 패킷 교환이 완료되었음을 전함.

이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 그와 동시에 같은 수순으로 패킷을 재전송한다.

### 1.5 이름 해결을 담당하는 DNS
DNS(Domain Name System)는 HTTP와 같이 응용 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. 사람에게 친숙한 도메인명에서 숫자로 되어있는 IP 주소를 조사하거나 반대로 IP 주소로부터 도메인명을 조사하는 서비스를 제공하고 있다.

### 1.6 각각과 HTTP와의 관계
1. 클라이언트가 DNS에 도메인명으로 요청한 IP 주소를 제공 받음.
2. HTTP 담당 : 웹 서버에 보낼 HTTP 메시지 작성.
3. TCP 담당 : 통신하기 쉽도록 HTTP 메시지를 패킷으로 분해.
4. IP 담당 : 상대가 어디에 있는지 찾아 중계해 가면서 배송.
5. TCP 담당 : 상대방으로부터 패킷을 수신.
6. HTTP 담당 : 웹 서버에 대한 리퀘스트 내용을 처리.
7. 서버에서 처리 결과를 마찬가지로 TCP/IP 통신 순서대로 클라이언트에 반환.

### 1.7 URI와 URL
#### 1.7.1 URI는 리소스 식별자
**URI(Uniform Resource Identifiers)**  
**Uniform** : 통일된 서식을 결정하는 것으로, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할 수 있게 한다. 또한, 새로운 스키마(http: 와 ftp 등) 도입을 용이하게 한다.

**Resource** : '식별 가능한 모든 것'으로서 도큐먼트 파일뿐만 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것은 모두 리소스이다. 리소스는 단일한 부분만 아니라 복수의 집합도 리소스로 파악할 수 있다.

**Identifier** : 식별 가능한 것을 참조하는 오브젝트이며 식별자로 불린다. 결국, URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자이다. **스키마**는 리소스를 얻기 위한 수단에 이름을 붙이는 방법이다.

#### 1.7.2 URL 포맷
URI는 필요한 정보 전체를 지정하는 완전 수식 절대 URI 혹은 완전 수식 절대 URL과 브라우저 중의 기준 URI에서 상대적 위치를 지정하는 상대 URI이 있다.

http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1

스키마 : http://  
자격정보(크리덴셜) : user:pass  
서버주소 : www.example.jp  
서버포트 : 80  
계층적 파일 패스 : dir/index.html  
쿼리 문자열 : uid=1  
프래그먼트 식별자 : ch1

## 제2장. 간단한 프로토콜 HTTP
### 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다
TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 한다. 리소스를 요구하는 쪽이 **클라이언트**가 되고, 리소스를 제공하는 쪽이 **서버**가 된다.

### 2.2 리퀘스트와 리스폰스를 교환하여 성립
HTTP는 클라이언트로부터 리퀘스트(요청, Request)가 송신되며, 그 결과가 서버로부터 리스폰스(응답, Response)로 되돌아온다.  

리퀘스트는 다음과 같이 구성된다.

GET /index.html  
HTTP /1.1  Host: www.hackr.jp

"GET"은 서버에 요구하는 종류를 나타내며 메소드라고 불린다. "/index.html"은 요구 대상인 리소스이며 리퀘스트 URI라고 한다. "HTTP /1.1"은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호이다.

리스폰스는 다음과 같이 구성된다.

HTTP /1.1 200 OK  
Date: Tue, 10 Jul 2012 06:50:15 GMT  
Content-Length: 362  
Content-Type: text/html  

html  
...

첫번째 줄에는 리퀘스트와 같이 서버의 HTTP 버전을 나타내고 있고, "200 OK"는 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명이다. 다음 줄은 리스폰스가 발생한 일시를 나타내는 헤더 필드의 정보들이 있다. 그리고 빈 줄로 구분한 아래 부분에 있는 부분이 바디(body)라고 불리는 리소스 본체이다.

### 2.3 HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜이다. 즉, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해 기억하지 않는다. 이는 많은 데이터를 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위함이다. 상태를 계속 유지하기 위한 기술로는 **쿠키(Cookie)** 가 있다.

### 2.4 리퀘스트 URI로 리소스를 식별
클라이언트는 리소스를 호출할 때마다 리퀘스트를 송신할 때 리퀘스트 URI라고 불리는 형식을 포함해야 할 필요가 있다. 리퀘스트 URI를 지정하는 방법에는 여러 종류가 있다.
1. 모든 URI를 리퀘스트 URI에 포함한다. 예) GEP http://hackr.jp/index.html HTTP/ 1.1
2. Host 헤더 필드에 네트워크 로케이션을 포함한다. 예) GET /index.html HTTP/ 1.1 Host: hackr.jp

특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는 리퀘스트 URI에 [*]을 지정할 수 있다. 예) OPTIONS * HTTP/1.1

### 2.5 서버에 임무를 부여하는 HTTP 메소드
**GET : 리소스 획득**  
GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다.

**POST : 엔티티 전송**  
GET으로도 엔티티를 전송할 수 있지만, 일반적으로는 POST를 사용한다.

**PUT : 파일 전송**  
PUT 메소드는 파일을 전송하기 위해서 사용된다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다. 그러나 HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 RESP(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있다.

**HEAD : 메시지 헤더 획득**  
GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.

**DELETE : 파일 삭제**  
DELETE 메소드는 PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. PUT 메소드와 마찬가지로 HTTP /1.1의 DELETE 자체에는 인증 기능이 없기 때문에 PUT과 비슷한 경우에 사용된다.

**OPTIONS : 제공하고 있는 메소드의 문의**  
OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.

**TRACE : 경로 조사**  
TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 클라이언트는 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다. TRACE 메소드는 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않는다.

**CONNECT : 프록시에 터널링 요구**  
CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL이랑 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해서 사용되고 있다.

### 2.6 메소드를 사용해서 지시를 내리다
리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라고 불리는 명령이 있다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재하며, GET과 POST, HEAD 등이 있다. 메소드는 대문자와 소문자를 구별하기 때문에 대문자로 기재할 필요가 있다.

### 2.7 지속 연결로 접속량을 절약
#### 2.7.1 지속 연결
HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해 **지속 연결(Persistent Connections)** 이라는 방법을 고안하였다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다는 것이다. 지속 연결의 이점은 TCP 커넥션의 연결과 종료의 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감되고, 오버헤드를 줄인 만큼 HTTP 통신이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다.

#### 2.7.2 파이프라인화
지속 연결은 여러 리퀘스트를 보낼 수 있도록 **파이프라인(HTTP pipelining)화**를 가능하게 한다. 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.

### 2.8 쿠키를 이용한 상태 관리
HTTP는 스테이트리스(stateless) 프로토콜이기 때문에 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않는다. 예를 들면, 인증한 웹 페이지에서 상태 관리를 하지 않는다면 새로운 페이지로 이동할 때마다 매번 인증을 해야 한다. 이러한 문제를 해결하기 위한 것이 쿠키이다.

쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 클라이언트에 보존하게 된다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신하면 서버는 클라이언트가 보내온 쿠키를 확인해 어느 클라이언트가 접속했는지 체크해서 이전 상태를 알 수 있다.

## 제3장. HTTP 정보는 HTTP 메시지에 있다
### 3.1 HTTP 메시지
HTTP 메시지는 복수 행의 데이터로 구성된 텍스트 문자열이다. HTTP 메시지는 크게 메시지 헤더와 메시지 바디로 구성되며, 최초에 나타나는 개행 문자로 헤더와 바디를 구분한다. 항상 메시지 바디가 존재하지는 않는다.

### 3.2 리퀘스트 메시지와 리스폰스 메시지의 구조
**리퀘스트 라인**  
리퀘스트에 사용하는 메소드와 리퀘스트 URI와 사용하는 HTTP 버전이 포함

**상태 라인**  
리스폰스 결과를 나타내는 상태 코드와 설명, 사용하는 HTTP 버전이 포함

**헤더 필드**  
리퀘스트와 리스폰스의 여러 조건과 속성 등을 나타내는 각종 헤더 필드가 포함. 일반 헤더 필드, 리퀘스트 헤더 필드, 리스폰스 헤더 필드, 엔티티 헤더 필드의 4종류

**그 외**  
HTTP의 RFC에는 없는 헤더 필드(쿠키 등)가 포함되는 경우

### 3.3 인코딩으로 전송 효율을 높이다
전송할 때 인코딩을 하면 다량의 액세스를 효율 좋게 처리할 수 있지만 컴퓨터에서 인코딩 처리를 해야 하기 때문에 CPU 등의 리소스는 보다 많이 소비하게 된다.

#### 3.3.1 메시지 바디와 엔티티 바디의 차이
**메시지(message)**  
HTTP 통신의 기본 단위로 **옥텟 시퀀스(Octet sequence, octet은 8비트)** 로 구성되고 통신을 통해서 전송된다.

**엔티티(entity)**  
리퀘스트랑 리스폰스의 페이로드(payload, 부가물)로 전송되는 정보로 엔티티 헤더 필드와 엔티티 바디로 구성된다.

기본적으로 메시지 바디와 엔티티 바디는 같지만 전송 코딩이 적용된 경우에는 엔티티 바디의 내용이 변화하기 때문에 메시지 바디와 달라진다.

#### 3.3.2 압축해서 보내는 콘텐츠 코딩
콘텐츠 코딩은 엔티티에 적용하는 인코딩을 가리키는데 엔티티 정보를 유지한 채 zip 등으로 압축해서 송신한다.

#### 3.3.3 분해해서 보내는 청크 전송 코딩
HTTP 통신에서는 리퀘스트했었던 리소스 전부에서 엔티티 바디의 전송이 완료되지 않으면 브라우저에 표시되지 않는다. 사이즈가 큰 데이터를 전송하는 경우에 데이터를 분할해서 조금씩 표시하는 기능을 **청크 전송 코딩(Chunked transfer Coding)** 이라고 한다.

### 3.4 여러 데이터를 보내는 멀티파트
메일의 경우 본문 텍스트나 복수의 첨부 파일 등을 붙여서 함께 보낼 수 있는데, 이것은 **MIME(Multipurpose Internet Mail Extensions: 다목적 인터넷 메일 확장 사양)** 으로 불리는 기능을 사용한다. MIME는 이미지 등의 바이너리 데이터를 아스키(ASCII) 문자열에 인코딩하는 방법과 데이터 종류를 나타내는 방법 등을 규정하고 있는데, 이 MIME의 확장 사양에 있는 멀티파트라고 하는 여러 다른 종류의 데이터를 수용하는 방법을 사용하고 있다. HTTP도 멀티파트에 대응하고 있어 하나의 메시지 바디 내부에 엔티티를 여러 개 포함시켜 보낼 수 있다.

멀티파트에는 다음과 같은 것들이 있다.  
multipart/form-data : Web 폼으로부터 파일 업로드에 사용  
multipart/byteranges : 상태 코드 206(Partial Content) 리스폰스 메시지가 복수 범위의 내용을 포함하는 때에 사용

HTTP 메시지로 멀티파트를 사용할 때에는 Content-type 헤더 필드를 사용하며, 각각의 엔티티를 구분하기 위해 "boundary" 문자열을 사용한다. 각 엔티티의 처음과 끝에 "--"를 삽입한다. (예 : "--AaB03x--")

### 3.5 일부분만 받는 레인지 리퀘스트
다운로드 중에 커넥션이 끊어지게 되면 처음부터 다시 다운로드를 해야한다. 이러한 문제를 해결하기 위해 **리줌(resume)** 이라는 기능이 필요하게 되었다. 이 기능을 실현하기 위해서는 엔티티의 범위를 지정해서 다운로드를 할 필요가 있다. 이와 같이 범위를 지정하여 리퀘스트 하는 것을 **레인지 리퀘스트(Range Request)** 라고 한다.

레인지 리퀘스트를 할 때에는 Range 헤더 필드를 사용해서 리소스의 바이트 레인지를 지정한다.

5,001 ~ 10,000 바이트  
`Range: bytes=5001-10000`

5,001 바이트 이상  
`Range: bytes=5001-`

처음부터 3,000 바이트까지, 그리고 5,000 ~ 7,000 바이트까지의 복수 범위  
`Range: bytes=-3000,5000-7000`

레인지 리퀘스트에 대한 리스폰스는 상태 코드 206 Partial Content 라는 리스폰스 메시지가 되돌아온다. 복수 범위의 레인지 리퀘스트에 대한 리스폰스는 multipart/byteranges로 되돌아온다. 서버가 레인지 리퀘스트를 지원하지 않는 경우에는 상태 코드 200 OK 라는 리스폰스 메시지로 완전한 엔티티가 되돌아온다.

### 3.6 최적의 콘텐츠를 돌려주는 콘텐츠 네고시에이션
내용은 같지만 영어판과 한국어판과 같이 표시되는 언어가 다른 웹 페이지와 같은 구조를 **콘텐츠 네고시에이션(Content Negotiation)** 이라고 한다. 콘텐츠 네고시에이션이란 클라이언트와 서버가 제공하는 리소스의 내용에 대해 교섭하는 것이다. 클라이언트에 더욱 적합한 리소스를 제공하기 위한 구조이다.

콘텐츠 네고시에이션에는 다음과 같은 종류들이 있다.

**서버 구동형 네고시에이션(Server-driven Negotiation)**  
서버 측에서 콘텐츠 네고시에이션을 하는 방식이다. 서버 측에서 리퀘스트 헤더 필드의 정보를 참고해서 자동적으로 처리한다. 단지, 브라우저가 보내는 정보를 근거로 하기 때문에 유저에게 정말로 적절한 것이 선택되었다고는 할 수 없다.

**에이전트 구동형 네고시에이션(Agent-driven Negotiation)**  
클라이언트 측에서 콘텐츠 네고시에이션을 하는 방식이다. 브라우저에 표시된 선택지 중에서 유저가 수동으로 선택한다. JavaScript 등으로 웹 페이지에서 자동적으로 정하는 것도 있다. 예를 들면, OS의 종류나 브라우저의 종류 등에 의해서 PC용과 스마트폰용 웹 페이지를 자동으로 전환하는 것이 이에 해당한다.

**트랜스페어런트 네고시에이션(Transparent Negotiation)**  
서버 구동형과 에이전트 구동형을 혼합한 것이다.

## 제4장. 결과를 전달하는 HTTP 상태 코드
### 4.1 상태 코드는 서버로부터 리퀘스트 결과를 전달한다
상태 코드는 3자리 숫자와 설명으로 나타내는데 첫 번째 자리는 리스폰스의 클래스를 의미하며, 다음과 같이 5개가 정의되어 있다.

**1xx (Informational 클래스)** : 리퀘스트를 받아들여 처리중  
**2xx (Success 클래스)** : 리퀘스트를 정상적으로 처리했음  
**3xx (Redirection 클래스)** : 리퀘스트를 완료하기 위해서 추가 동작이 필요  
**4xx (Client Error 클래스)** : 서버는 리퀘스트 이해 불가능  
**5xx (Server Error 클래스)** : 서버는 리퀘스트 처리 실패

### 4.2 2xx 성공(Success)
2xx 리스폰스는 리퀘스트가 정상으로 처리되었음을 나타낸다.

#### 4.2.1 200 OK
클라이언트가 보낸 리퀘스트를 서버가 정상 처리하였음을 나타낸다.

#### 4.2.2 204 No Content
서버가 리퀘스트를 받아서 처리하는 데는 성공했지만 리스폰스에 엔티티 바디를 포함하지 않는다. 클라이언트에 새로운 정보를 보낼 필요가 없는 경우이다.

#### 4.2.3 206 Partial Content
Range에 의해서 범위가 지정된 리퀘스트에 의해서 서버가 부분적 GET 리퀘스트를 받았음을 나타낸다. 리스폰스에는 Content-Range로 지정된 범위의 엔티티가 포함된다.

### 4.3 3xx 리다이렉트(Redirection)
3xx 리스폰스는 리퀘스트가 정상적으로 처리를 종료하기 위해 브라우저 측에서 특별한 처리를 수행해야 함을 나타낸다.

#### 4.3.1 301 Moved Permanently
리퀘스트 된 리소스에는 새로운 URI가 부여되어 있기 때문에 이후로는 그 리소스를 참조하는 URI를 사용해야 한다는 것을 나타낸다. 디렉토리를 지정했을 때 마지막 부분에 슬래시(/)를 붙이는 것을 잊을 경우 등이다.  
`http://example.com/sample`

#### 4.3.2 302 Found
리퀘스트 된 리소스에는 새로운 URI가 할당되어 있기 때문에 그 URI를 참조해 주길 바란다는 의미를 나타낸다. 301 Moved Permanently와 비슷하지만 302의 경우에는 영구적인 이동이 아닌 일시적인 것이다.

#### 4.3.3 303 See Other
리퀘스트에 대한 리소스는 다른 URI에 있기 때문에 GET 메소드를 사용해야 얻어햐 한다는 의미이다. 이것은 302 Found와 같은 기능이지만 리다이렉트 장소를 GET 메소드로 얻어야 한다고 명확하게 되어있는 점이 다르다. 예를 들면, POST 메소드로 액세스한 CGI 프로그램을 실행한 후에 처리 결과를 별도의 URI에 GET 메소드로 리다이렉트 시키고 싶은 경우 등에 303이 사용된다. 302 Found 라도 같은 일이 가능하지만 303을 사용하는 것이 바람직하다.

#### 4.3.4 304 Not Modified
클라이언트가 조건부 리퀘스트를 했을 때 리소스에 대한 액세스는 허락하지만 조건이 충족되지 않음을 표시한다. 304를 되돌려 줄 경우에는 리스폰스 바디에 어떤 것도 포함되면 안된다. 304는 3xx에 분류되어 있지만 리다이렉트와는 관계가 없다.

#### 4.3.5 307 Temporary Redirect
302 Found와 같은 의미를 지니지만 302의 경우에는 POST로부터 GET으로 치환이 금지되어 있는데도 불구하고 구현상 그와 같이 되어 있지는 않다. 307에서는 브라우저 사양에 따라 POST에서 GET으로 치환을 하지 않는다.

### 4.4 4xx 클라이언트 에러(Client Error)
4xx 리스폰스는 클라이언트의 원인으로 에러가 발생했음을 나타낸다.

#### 4.4.1 400 Bad Request
리퀘스트 구문이 잘못되었음을 나타낸다. 브라우저는 이것을 200 OK와 같이 취급한다.

#### 4.4.2 401 Unauthorized
송신한 리퀘스트에 HTTP 인증 정보가 필요하다는 것을 나타낸다. 이미 1번 리퀘스트가 이루어진 경우에는 유저 인증에 실패했음을 표시한다.

#### 4.4.3 403 Forbidden
리퀘스트 된 리소스의 액세스가 거부되었음을 나타낸다. 403이 발생한 원인으로는 파일 시스템의 퍼미션이 부여되지 않은 경우와 액세스 권한에 문제가 있는 것 등이 있다.

#### 4.4.4 404 Not Found
리퀘스트한 리소스가 서버상에 없다는 것을 나타낸다. 서버 측에 해당 리퀘스트를 거부하고 싶은 이유를 분명히 하고 싶지 않은 경우에도 해당된다.

### 4.5 서버 에러(Server Error)
5xx 리스폰스는 서버 원인으로 에러가 발생하고 있음을 나타낸다.

#### 4.5.1 500 Internal Server Error
서버에서 리퀘스트를 처리하는 도중에 에러가 발생하였음을 나타낸다. 웹 애플리케이션 에러가 발생한 경우나 일시적인 경우도 있다.

#### 4.5.2 503 Serveice Unavaliable
일시적으로 서버가 과부하 상태이거나 점검중이기 때문에 현재 리퀘스트를 처리할 수 없음을 나타내고 있다.

## 제5장. HTTP와 연계하는 웹 서버
### 5.1 1대로 멀티 도메인을 가능하게 하는 가상 호스트
HTTP/1.1에서는 하나의 HTTP 서버에 여러 개의 웹 사이트를 실행할 수 있는데, 이를 위해 **가상 호스트(Virtual Host)** 라는 기능을 사용한다. 가상 호스트 기능을 사용하면 물리적으로는 서버가 1대지만 가상으로 여러 대가 있는 것처럼 설정할 수 있다.

HTTP를 사용해서 클라이언트가 서버에 액세스할 때는 호스트명이나 도메인명을 주로 사용하게 된다. 도메인명은 DNS에 의해서 IP주소로 변환되고 난 후 액세스하게 되기 때문에, 1대의 서버 안에 여러 개의 도메인이 있을 경우 어느 쪽에 대한 액세스인지 알 수가 없다. 따라서 HTTP 리퀘스트를 보내는 경우 호스트명과 도메인명을 완전하게 포함한 URI를 지정하거나 반드시 Host 헤더 필드에서 지정해야 한다.

### 5.2 통신을 중계하는 프로그램 : 프록시, 게이트웨이, 터널
HTTP는 클라이언트와 서버 이외에 **프록시(Proxy), 게이트웨이(Gateway), 터널(Tunnel)** 과 같은 통신을 중계하는 프로그램과 서버를 연계하는 것도 가능하다. 이러한 프로그램과 서버는 그 다음에 있는 다른 서버에 리퀘스트를 중계하고, 그 서버로부터 받은 리스폰스를 클라이언트에 반환하는 역할을 담당한다.

**프록시(Proxy)**  
서버와 클라이언트의 양쪽 역할을 하는 중계 프로그램으로, 클라이언트로부터의 리퀘스트를 서버에 전송하고 서버로부터의 리스폰스를 클라이언트에 전송한다.

**게이트웨이(Gateway)**  
다른 서버를 중계하는 서버로, 클라이언트로부터 수신한 리퀘스트를 리소스를 보유한 서버인 것처럼 수신한다. 클라이언트는 상대가 게이트웨이라는 것을 알지 못할 수도 있다.

**터널(Tunnel)**  
서로 떨어진 두 대의 클라이언트와 서버 사이를 중계하며 접속을 주선하는 중계 프로그램이다.

#### 5.2.1 프록시
프록시 서버를 사용하는 이유는 캐시를 사용해서 네트워크 대역 등을 효율적으로 사용하는 것과 조직 내에 특정 웹 사이트에 대한 액세스 제한, 액세스 로그를 획득하는 정책을 철저하게 지키려는 목적으로 사용하는 경우도 있다.

프록시의 사용 방법은 2개의 기준으로 분류하는데, 캐시하는지 안하는지 여부(캐싱 프록시)로 구분하거나 메시지를 변경하는지 안하는지 여부(투명 프록시)로 구분한다. 메시지에 변경을 가하는 타입의 프록시를 **비투과 프록시**라고 한다.

#### 5.2.2 게이트웨이
게이트웨이의 경우에는 그 다음에 있는 서버가 HTTP 서버 이외의 서비스를 제공하는 서버가 된다. 클라이언트와 게이트웨이 사이를 암호화하는 등으로 안전하게 접속함으로써 통신의 안전성을 높이는 역할 등을 수행한다.

#### 5.2.3 터널
터널은 요구에 따라서 다른 서버와의 통신 경로를 확립한다. 터널 자체는 HTTP 리퀘스트를 해석하려고 하지 않으며 리퀘스트를 그대로 다음 서버에 중계하고 통신하고 있는 양쪽 끝의 접속이 끊어질 때에 종료한다.

### 5.3 리소스를 보관하는 캐시
캐시(Cache)는 프록시 서버와 클라이언트의 로컬 디스크에 보관된 리소스의 사본을 가리킨다. 캐시를 사용하면 리소스를 가진 서버에의 액세스를 줄이는 것이 가능하기 때문에 통신량과 통신 시간을 절약할 수 있다. 캐시 서버는 프록시 서버의 하나로 캐싱 프록시로 분류된다. 캐시는 유효기간이 있으며 클라이언트 측에서 캐시가 있다.

## 제6장. HTTP 헤더
### 6.1 HTTP 메시지 헤더
HTTP 프로토콜의 리퀘스트와 리스폰스에는 반드시 메시지 헤더가 포함되어 있는데 메시지 헤더에는 클라이언트나 서버가 리퀘스트나 리스폰스를 처리하기 위한 정보가 들어있다.

리퀘스트의 HTTP 메시지 : 메소드, URI, HTTP 버전, HTTP 헤더 필드 등으로 구성  
리스폰스의 HTTP 메시지 : HTTP 메시지, HTTP 버전, 상태 코드(코드와 설명), HTTP 헤더 필드 등으로 구성

### 6.2 HTTP 헤더 필드
#### 6.2.1 HTTP 헤더 필드는 중요한 정보를 전달한다
HTTP 헤더 필드는 HTTP 프로토콜 중에서 클라이언트와 서버 간의 통신에서 리퀘스트에도 리스폰스에도 사용되고 있고, 부가적으로 중요한 정보를 전달하는 역할을 담당하고 있다.

#### 6.2.2 HTTP 헤더 필드의 구조
HTTP 헤더 필드는 헤더 필드 명과 필드 값으로 구성되어 있고 콜론 ":" 으로 나뉘어져 있다.  
``헤더 필드 명 : 필드 값``  
``예) Content-Type : text/html``

#### 6.2.3 4종류의 HTTP 헤더 필드
1. 일반적 헤더 필드(General Header Fields) : 리퀘스트 메시지와 리스폰스 메시지 둘 다 사용되는 헤더
2. 리퀘스트 헤더 필드(Request Header Fields) : 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더. 리퀘스트의 부가적 정보와 클라이언트의 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 부가
3. 리스폰스 헤더 필드(Response Header Fields) : 서버 측에서 클라이언트 측으로 송신한 리스폰스 메시지에 사용되는 헤더. 리스폰스의 정보와 서버의 정보, 클라이언트의 추가 정보 요구 등을 부가
4. 엔티티 헤더 필드(Entity Header Fields) : 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더. 콘텐츠 갱신 시간 등의 엔티티에 관한 정보를 부가

#### 6.2.4 HTTP/1.1 헤더 필드 일람
**일반 헤더 필드**  
Cache-Control : 캐싱 동작 지정  
Connection : Hop-by-hop 헤더, 커넥션 관리  
Date : 메시지 생성 날짜  
Pragma : 메시지 제어  
Trailer : 메시지의 끝에 있는 헤더의 일람  
Transfer-Encoding : 메시지 바디의 전송 코딩 형식 지정  
Upgrade : 다른 프로토콜에 업그레이드  
Via : 프록시 서버에 관한 정보  
Warning : 에러 통지

**리퀘스트 헤더 필드**  
Accept : 유저 에이전트가 처리 가능한 미디어 타입  
Accept-Charset : 문자셋 우선 순위  
Accept-Encoding : 콘텐츠 인코딩 우선 순위  
Accept-Language : 언어(자연어) 우선 순위  
Authorization : 웹 인증을 위한 정보  
From : 유저의 메일 주소  
Host : 요구된 리소스의 호스트  
Range : 엔티티 바이트 범위 요구  
User-Agent : HTTP 클라이언트의 정보  
...

**리스폰스 헤더 필드**  
Accept-Ranges : 바이트 단위의 요구를 수신할 수 있는지 없는지 여부  
Age : 리소스의 지정 경과 시간  
Location : 클라이언트를 지정한 URI에 리다이렉트  
Server : HTTP 서버 정보  
...

**엔티티 헤더 필드**  
Allow : 리소스가 제공하는 HTTP 메소드  
Content-Encoding : 엔티티 바디에 적용되는 콘텐츠 인코딩  
Content-Language : 엔티티의 자연어
Content-Length : 엔티티 바디의 사이즈(단위: 바이트)  
Content-Location : 리소스에 대응하는 대체 URI  
Content-Range : 엔티티 바디의 범위 위치  
Content-Type : 엔티티 바디의 유효기한 날짜  
Expires : 엔티티 바디의 유효기한 날짜  
...

#### 6.2.5 HTTP/1.1 이외의 헤더 필드
HTTP에서 교환되는 HTTP 헤더 필드는 RFC2616에서 정의된 47종류 외에 쿠키와 Set-Cookie, Content-Disposition과 같이 RFC에 정의되어 폭 넓게 사용되고 있는 것도 있다.

#### 6.2.6 End-to-end 헤더와 Hop-by-hop 헤더
**End-to-end 헤더**  
이 카테고리에 분류된 헤더는 리퀘스트나 리스폰스의 최종 수신자에게 전송된다. 캐시에서 구축된 리스폰스 중 보존되어야 하고, 다시 전송되지 않으면 안되도록 되어있다.

**Hop-by-hop 헤더**  
이 카테고리에 분류된 헤더는 한 번 전송에 대해서만 유효하고 캐시와 프록시에 의해서 전송되지 않는 것도 있다. HTTP/1.1과 그 이후에서 사용되는 Hop-by-hop 헤더는 Connection 헤더 필드에 열거해야 한다.

HTTP/1.1에서 hop-by-hop 헤더는 다음과 같은 것들이 있다. 다음의 8개의 헤더 필드 이외에는 모두 End-by-end 헤더에 분류된다.  
``Connection, Keep-Alive, Proxy-Authenticate, Proxy-Authorization, Trailer, TE, Transfer-Encoding, Upgrade``

### 6.3 HTTP/1.1 일반 헤더 필드
일반 헤더 필드는 리퀘스트 메시지와 리스폰스 메시지 양쪽에서 사용되는 헤더이다.

#### 6.3.1 Cache-Control
Cache-Control 헤더는 디렉티브로 불리는 명령을 사용하여 캐싱 동작을 지정한다.

지정한 디렉티브에는 파라미터가 있는 것과 없는 것도 있으며 여러 개의 디렉티브를 지정하는 경우에는 콤마 ","로 구분한다.  
``Cache-Control: private, max-age=0, no-cache``

**캐시가 가능한지 여부를 나타내는 디렉티브**  
1) public 디렉티브 : ``Cache-Control: public`` 다른 유저에게도 돌려줄 수 있는 캐시를 해도 좋다는 것을 명시적으로 나타낸다. 
2) private 디렉티브 : ``Cache-Control: private`` 리스폰스는 특정 유저만을 대상으로 하고 있다는 것을 나타낸다. public 디렉티브와 기능이 반대이다.
3) no-cache 디렉티브 : ``Cache-Control: no-cache`` 캐시로부터 오래된 리소스가 반환되는 것을 막기 위해 사용된다.

**캐시로 보존 가능한 것을 제어하는 디렉티브**  
1) no-store 디렉티브 : ``Cache-Control: no-store`` 리퀘스트(그와 대응되는 리스폰스) 혹은 리스폰스에 기밀 정보가 포함되어 있음을 나타낸다.

**캐시 기한이나 검증을 지정하는 디렉티브**  
1) s-maxage 디렉티브 : ``Cache-Control: s-maxage=604800 (단위 : 초)`` s-maxage 디렉티브의 기능은 max-age 디렉티브와 동일한데 다른 점은 여러 유저가 이용할 수 있는 공유 캐시 서버에만 적용된다는 것이다. s-maxage 디렉티브가 사용되는 경우, Expires 헤더 필드와 max-age 디렉티브는 무시된다.
2) max-age 디렉티브 : ``Cache-Control: max-age=604800 (단위 : 초)`` 클라이언트의 리퀘스트로 max-age 디렉티브가 사용되었다면 지정되었던 값보다 새로운 경우에는 캐시되었던 리소스를 받아들일 수 있다. 서버의 리스폰스에서 max-age 디렉티브가 사용되는 경우, 캐시 서버가 유효성의 재확인을 하지 않고 리소스를 캐시에 보존해 두는 최대 시간을 나타낸다.

이외에도 min-fresh 디렉티브, max-stale 디렉티브, only-if-cached 디렉티브, must-revalidate 디렉티브 등이 있다.

#### 6.3.2 Connection
Connection 헤더 필드는 다음의 두 가지 역할을 한다.  
1. 프록시에 더 이상 전송하지 않는 헤더 필드를 지정
2. 지속적 접속 관리 : HTTP/1.1에서는 지속적 접속이 디폴트이다. 리퀘스트를 송신했던 클라이언트는 접속이 계속 유지되면서 추가 리퀘스트를 송신하도록 한다. 서버 측에서 명시적으로 접속을 끊고 싶을 경우네는 Connection 헤더 필드에 Close라고 지정한다. 지속적 접속이 디폴트가 아닌 오래된 버전 등에서는 Keep-Alive라고 지정해서 지속적 접속을 사용한다.

#### 6.3.3 Date
Date 헤더 필드는 HTTP 메시지를 생성한 날짜를 나타낸다.  
``Date: Tue, 03 Jul 2012 04:40:50 GMT``

#### 6.3.4 Pragma
Pragma 헤더 필드는 HTTP/1.1 보다 오래된 버전의 흔적으로 HTTP/1.0 과의 후방 호환성만을 위해서 정의되어 있는 헤더 필드이다.  
지정할 수 있는 형식은 다음과 같이 1개뿐이다. ``Pragma: no-cache``

#### 6.3.5 Trailer
Trailer 헤더 필드는 메시지 바디의 뒤에 기술되어 있는 헤더 필드를 미리 전달할 수 있다.

#### 6.3.6 Transfer-Encoding
Transfer-Encoding 헤더 필드는 메시지 바디의 전송 코딩 형식을 지정하는 경우에 사용된다.

#### 6.3.7 Upgrade
Upgrade 헤더 필드는 HTTP 및 다른 프로토콜의 새로운 버전이 통신에 이용되는 경우에 사용된다.

#### 6.3.8 Via
Via 헤더 필드는 클라이언트와 서버 간의 리퀘스트 혹은 리스폰스 메시지의 경로를 알기 위해서 사용된다. 프록시 혹은 게이트웨이는 자신의 서버 정보를 Via 헤더 필드에 추가한 뒤에 메시지를 전송한다.

#### 6.3.9 Warning
Warning 헤더는 HTTP/1.0 리스폰스 헤더가 HTTP/1.1에서 변경된 것으로, 리스폰스에 관한 추가 정보를 전달한다.

### 6.4 리퀘스트 헤더 필드
리퀘스트 헤더 필드는 클라이언트 측에서 서버 측으로 송신된 리퀘스트 메시지에 사용되는 헤더로, 리퀘스트의 부가 정보와 클라이언트 정보, 리스폰스의 콘텐츠에 관한 우선 순위 등을 추가한다.  
리퀘스트 헤더 필드에는 다음과 같은 것들이 있다. Accept, Accept-Charset, Accept-Encoding, Accept-Language, Authorization, Expect, From, Host, If-Match, If-Modified-Since, If-None-Match, If-Range, ...

### 6.5 리스폰스 헤더 필드
리스폰스 헤더 필드는 서버 측으로부터 클라이언트 측으로 송신되는 리스폰스 메시지에 적용된 헤더로 리스폰스의 부가 정보나 서버의 정보, 클라이언트에 부가 정보 요구 등을 나타낸다.  
리스폰스 헤더 필드에는 다음과 같은 것들이 있다. Accept-Ranges, Age, ETag, Location, Proxy-Authenticate, Retry-After, Server, Vary, ...

### 6.6 엔티티 헤더 필드
엔티티 헤더 필드는 리퀘스트 메시지와 리스폰스 메시지에 포함된 엔티티에 사용되는 헤더로 콘텐츠의 갱신 시간 같은 엔티티에 관한 정보를 포함한다.  
엔티티 헤더 필드에는 다음과 같은 것들이 있다. Allow, Content-Encoding, Content-Language, Content-Length, Content-Location, Content-MD5, Content-Range, Content-Type, Expires, ...

### 6.7 쿠키를 위한 헤더 필드
쿠키는 유저 식별과 상태 관리에 사용되고 있는 기능이다. 웹 사이트가 유저의 상태를 관리하기 위해서 웹 브라우저 경유로 유저의 컴퓨터 상에 일시적으로 데이터를 기록해 두고, 다음에 그 유저가 웹 사이트에 액세스 해 왔을 때 지난번에 발행한 쿠키를 송신받을 수 있다.

#### 6.7.1 Set-Cookie
서버가 클라이언트에 대해서 상태 관리를 시작할 때 다양한 정보를 전달한다.
1) Expires 속성 : 브라우저가 쿠키를 송출할 수 있는 유효 기한을 지정
2) Path 속성 : 쿠키를 송출하는 범위를 특정 디렉토리에 한정
3) Domain 속성 : 쿠키의 domain 속성에 의해서 지정된 도메인 명은 후방 일치가 된다.
4) Secure 속성 : 웹 페이지가 HTTPS에서 열렸을 때만 쿠키 송출을 제한하기 위해서 지정
5) HttpOnly 속성 : 자바스크립트를 경유해서 쿠키를 취득하지 못하도록 하는 쿠키의 확장 기능

#### 6.7.2 Cookie
클라이언트가 HTTP의 상태 관리 지원을 원할 때 서버로부터 수신한 쿠키를 이후의 리퀘스트에 포함해서 전달

## 제7장. 웹을 안전하게 하는 HTTPS
### 7.1 HTTP의 약점
- 평문(암호화하지 않은) 통신이기 때문에 도청 가능
- 통신 상대를 확인하지 않기 때문에 위장 가능  
- 완전성을 증명할 수 없기 때문에 변조 가능

#### 7.1.1 평문이기 때문에 도청 가능
TCP/IP 구조의 통신 내용은 전부 통신 경로의 도중에 엿볼 수 있다. 도청으로부터 정보를 지키기 위한 방법 중 가장 보급되어 있는 기술은 암호화이다.
1) 통신 암호화 : HTTP에는 암호화 구조는 없지만 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 다른 프로토콜을 조합함으로써 HTTP의 통신 내용을 암호화한다. SSL을 조합한 HTTP를 **HTTPS**라 한다.
2) 콘텐츠 암호화 : 통신하고 있는 콘텐츠의 내용 자체를 암호화한다. 즉, HTTP 메시지에 포함되는 콘텐츠만 암호화한다.

#### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능
HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않기 때문에 SSL로 상대를 확인할 수 있다. SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다.

#### 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능
HTTP가 완전성을 증명할 수 없다는 것은 리퀘스트나 리스폰스가 발신된 후에 상대가 수신할 때까지의 사이에 변조되었다고 해도 이 사실을 알 수 없다는 것이다. 공격자가 도중에 리퀘스트나 리스폰스를 빼앗아 변조하는 중간자 공격(Man-in-the-Middle 공격)이 있기 때문이다. 변조를 방지하기 위해서는 MD5나 SHA-1 등의 해시 값을 확인하는 방법과 파일의 디지털 서명을 확인하는 방법이 있다.

### 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS
#### 7.2.1 HTTP에 암호화와 인증과 완전성 보호를 더한 HTTPS
HTTP의 문제를 해결하기 위해 암호화나 인증 등의 구조를 더한 것을 HTTP라고 부른다. 

#### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP
HTTPS는 새로운 애플리케이션 계층의 프로토콜은 아니다. HTTP 통신을 하는 소켓 부분을 SSL(Secure Socket Layer)이나 TLS(Transport Layer Security)라는 프로토콜로 대체하고 있을 뿐이다.

#### 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식
SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있다.

암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키 암호라고 한다. 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안된다. 키를 보내면 도청될 가능성이 있고, 키를 보내지 않으면 복호화 할 수 없다. 이러한 공통키 암호의 문제를 해결하려고 한 것이 **공개키 암호**라는 방식이다. 공개키 암호에서는 서로 다른 두 개의 키 쌍을 사용한다. 한 쪽은 비밀키(private key)라고 부르고 다른 한 쪽은 공개키(public key)라고 한다. 비밀키는 누구에게도 알려지면 안되는 키이고 공개키는 누구에게나 알려져도 괜찮은 키이다.

#### 7.2.4 공개키가 정확한지 아닌지를 증명하는 증명서
공개키 암호에도 문제점이 있는데 공개키가 진짜인지 아닌지를 증명할 수 없다는 것이다. 이 문제를 해결하기 위해 인증 기관(CA: Certificate Authority)과 그 기관이 발행하는 공개키 증명서가 이용되고 있다.

#### 7.2.5 안전한 통신을 하는 HTTPS의 구조
1. 클라이언트가 Client Hello 메시지를 송신하면서 SSL 통신을 시작
2. 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답
3. 서버가 Certificate 메시지를 송신. 메시지에는 공개키 증명서가 포함
4. 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션 부부이 끝났음을 통지
5. SSL의 최초 네고시에이션이 종료되면 클라이언트가 Client Key Exchange 메시지로 응답
6. 클라이언트는 Change Cipher Spec 메시지를 송신
7. 클라이언트는 Finished 메시지를 송신
8. 서버에서도 마찬가지로 Change Cipher Spec 메시지를 송신
9. 서버에서도 마찬가지로 Finished 메시지를 송신
10. 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속 확립
11. 애플리케이션 계층의 프로토콜에 의한 통신이다. 즉, HTTP 리스폰스를 송신
12. 마지막에 클라이언트가 접속을 끊는다. 접속을 끊을 경우에는 close_notify 메시지를 신

## 제8장. 누가 액세스하고 있는지를 확인하는 인증
### 8.1 인증이란?
컴퓨터는 모니터 앞에 앉아있는 사람이 누구인지 알 수 없다. 시스템에 액세스하는 권한을 가진 본인임을 확인하기 위한 정보에는 다음과 같은 것들이 있다.

- 패스워드 : 본인만이 알고 있는 문자열 정보
- 원타임 토큰 : 본인만이 가지고 있는 기기 등에 표시되는 한 번 쓰고 버리는 패스워드 등의 정보
- 전자 증명서 : 본인(단말기)만이 가지고 있는 정보
- 바이오 매트릭스 : 지문이나 홍채 등 본인의 신체 정보
- IC 카드 등 : 본인만이 가지고 있는 정보

**HTTP에서 사용하는 인증 방법**  
HTTP/1.1에서 이용할 수 있는 인증 방식에는 다음과 같은 것들이 있다. BASIC 인증, DIGEST 인증, SSL 클라이언트 인증, 폼 베이스 인증

### 8.2 BASIC 인증
BASIC 인증은 웹 서버와 대응하고 있는 클라이언트 사이에서 이뤄지는 인증 방식이다.

#### 8.2.1 BASIC 인증 수순
1. BASIC 인증이 필요한 리소스에 리퀘스트가 있을 경우, 서버는 상태 코드 401 Authorization Required와 함께 인증의 방식(BASIC)과 Request-URI의 보호 공간을 식별하기 위한 문자열(realm)을 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환한다.
2. 상태 코드 401을 받은 클라이언트는 BASIC 인증을 위해 유저 ID와 패스워드를 서버에 송신해야 한다. 송신하는 문자열은 유저 ID와 패스워드를 콜론(:)으로 연결한 문장을 Base64라 불리는 형식으로 인코드한 것이다. 이 문자열을 Authorization 헤더 필드에 포함해서 리퀘스트를 송신한다.
3. Authorization 헤더 필드를 포함한 리퀘스트를 수신한 서버는 인증 정보가 정확한지 여부를 판단한다. 인증 정보가 정확하면 Request-URI 리소스를 포함한 리스폰스를 반환한다.

BASIC 인증에서는 Base64라는 인코딩 형식을 사용하고 있지만 암호화는 아니기 때문에 아무런 부가 정보 없이도 복호화 할 수가 있기 때문에, 암호화되지 않은 통신 경로 상에서 도청된 경우에는 유저 ID와 패스워드를 빼앗길 가능성이 있다. 또, 한 번 BASIC 인증을 하면 일반 브라우저에서는 로그아웃할 수 없다는 문제도 있다.

### 8.3 DIGEST 인증
DIGEST 인증은 BASIC 인증의 약점을 보완한 인증 방식으로, 챌린지 리스폰스 방식이 사용되고 있어서 패스워드를 있는 그대로 보내는 일이 없다. **챌린지 리스폰스 방식**은 최초에 상대방에게 인증 요구를 보내고 상대방 측에서 받은 챌린지 코드를 사용해서 리스폰스 코드를 계산한 후, 이 값을 상대에게 송신하여 인증을 하는 방법이다.

#### 8.3.1 DIGEST 인증 수순
1. 인증이 필요한 리소스에 리퀘스트가 있을 경우, 서버는 상태 코드 401 Authorization Required와 함께 챌린지 리스폰스 방식의 인증에 필요한 챌린지 코드(nonce)를 WWW-Authenticate 헤더 필드에 포함해서 리스폰스를 반환한다. WWW-Authenticate 헤더 필드에 반드시 포함되어야 하는 정보는 "realm"과 "nonce" 두 개이다. nonce는 401 리스폰스를 반환할 때마다 생성되는 유일한 문자열이다. 이 문자열은 Base64이거나 16진수가 권장되고 있다.
2. 상태 코드 401을 수신한 클라이언트는 DIGEST 인증을 위해 필요한 정보를 Authorization 헤더 필드에 포함해서 리스폰스를 반환한다. Authorization 헤더 필드에 반드시 포함되어야 하는 정보는 "username", "realm", "nonce", "uri", "response"인데, "realm"하고 "nonce"는 서버에서 받은 것을 사용한다. "response"는 Request-Digest라고 불리는데 패스워드 문자열을 MD5로 계산한 것으로, 이것이 리스폰스 코드이다.
3. Authorization 헤더 필드를 포함한 리퀘스트를 받은 서버는 인증 정보가 정확한 것인지 아닌지를 판단하여 인증 정보가 정확한 경우 Request-URI의 피소스를 포함한 리스폰스를 반환한다.

DIGEST 인증은 BASIC 인증에 비해서 높은 보안 등급을 제공하고 있지만, HTTPS의 클라이언트 인증 등과 비교하면 낮다. DIGESt 인증에서는 패스워드의 도청을 방지하기 위한 보호 기능은 제공하고 있지만 이외에 위장을 방지하는 기능은 제공하고 있지 않다.

### 8.4 SSL 클라이언트 인증
SSL 클라이언트 인증은 HTTPS의 클라이언트 인증서를 이용한 인증 방식이다. 사전에 등록된 클라이언트에서의 액세스인지 아닌지를 확인한다.

#### 8.4.1 SSL 클라이언트 인증의 인증 수순
1. 인증이 필요한 리소스의 리퀘스트가 있을 경우, 서버는 클라이언트에게 증명서를 요구하는 "Certificate Request"라는 메시지를 송신한다.
2. 유저는 송신하는 클라이언트 증명서를 선택하여 "Client Certificate"라는 메시지를 송신한다.
3. 서버는 클라이언트 증명서를 검증하여 결과가 정확하다면 클라이언트의 공개키를 취득한 후 HTTPS에 의한 암호를 개시한다.

#### 8.4.2 SSL 클라이언트 인증은 2-factor 인증에서 사용된다
SSL 클라이언트 인증은 대부분의 경우 단독으로 사용되지는 않고 폼 베이스 인증과 합쳐서 2-factor 인증의 하나로서 이용되고 있다. 2-factor 인증이란 예를 들면 패스워드라는 한 개의 요소만이 아닌 이용자가 가진 다른 정보를 병용해서 인증하는 방법을 말한다.

#### 8.4.3 SSL 클라이언트 인증은 이용하는데 비용이 필요하다
SSL 클라이언트 인증에서는 클라이언트 증명서를 이용하는데, 이 클라이언트 증명서를 이용하기 위해서는 비용이 필요하게 된다.

### 8.5 폼 베이스 인증
폼 베이스 인증은 클라이언트가 서버 상의 웹 애플리케이션에 자격 정보(Credential)를 송신하여 그 자격 정보의 검증 결과에 따라 인증을 하는 방식이다. 대부분의 경우에는 사전에 등록해 둔 자격 정보인 유저 ID와 패스워드를 입력해서 이것을 웹 애플리케이션 측에 송신하고 검증 결과를 토대로 성공 여부를 결정한다.

#### 8.5.1 인증의 대부분은 폼 페이스 인증
HTTP가 표준으로 제공하는 BASIC 인증이나 DIGEST 인증은 사용상의 문제와 보안적인 문제로 거의 사용되고 있지 않다. 또한 보안 등급이 높은 SSL 클라이언트 인증도 비용의 문제로 널리 사용되고 있지는 못하고 있다. 웹 사이트의 인증 기능으로서 요구되는 기능의 레벨을 충족시킨 표준적인 것이 존재하지 않기 때문에 웹 애플리케이션에서 제각각 구현하는 폼 베이스 인증을 채용하는 수 밖에 없다.

#### 8.5.2 세션 관리와 쿠키에 의한 구현
폼 베이스 인증의 인증 자체는 서버 측의 웹 애플리케이션 등에 의해서 클라이언트가 송신해 온 유저 ID와 패스워드가 사전에 등록하고 있는 것과 일치하는지를 검즈아면서 이루어진다. 그러나 HTTP는 stateless 프로토콜이기 때문에 세션 관리와 쿠키를 사용하여 상태 관리 기능을 보충한다.

1. 클라이언트와 서버에 유저 ID나 패스워드 등의 자격 정보를 포함한 리퀘스트를 송신한다.
2. 서버 측은 유저를 식별하기 위한 세션 ID를 발행한다. 클라이언트에서 수신한 자격 정보를 검증하는 것으로 인증을 하고, 그 유저의 인증 상태를 세션 ID와 연관지어 서버 측에 기록한다. 클라이언트 측에 송신할 때는 Set-Cookie 헤더 필드에 세션 ID를 저장해서 리스폰스를 반환한다.
3. 서버 측에서 세션 ID를 받은 클라이언트는 쿠키로 저장해 둔다. 다음 번에 서버에 리퀘스트를 송신하는 때에는 브라우저가 자동으로 쿠키를 송출하기 때문에 세션 ID가 서버에 송신된다.

## 제9장. HTTP에 기능을 추가한 프로토콜
### 9.1 HTTP를 기본으로 하는 프로토콜
HTTP의 규격이 만들어졌을 무렵에는 주로 HTML로 작성된 문서를 전송하기 위한 프로토콜로 HTTP를 생각했었다. 그리고 시대를 거치면서 웹의 용도는 크게 변화하고 있고 부족한 HTTP의 기능을 보완하기 위해 HTTP를 기반으로 한 새로운 프로토콜이 몇 가지 구현되었다.

### 9.2 HTTP의 병목 현상을 해소하는 SPDY
Google이 2010년에 발표한 SPDY(스피디)는 HTTP의 병목 현상을 해소하고 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발되고 있다.

#### 9.2.1 HTTP의 병목 현상
다음과 같은 HTTP의 사양은 병목 현상이 된다.

- 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다.
- 리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것을 불가능하다.
- 리퀘스트/리스폰스 헤더를 압축하지 않은 채로 보낸다. 헤더의 정보가 많을수록 지연이 심해진다.
- 장황한 헤더를 보낸다. 매번 같은 헤더를 보내는 것은 낭비다.
- 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지는 않다.

**Ajax에 의한 해결 방법**  
**Ajax(Asynchronous JavaScript+XML)** 은 JavaScript나 DOM(Document Object Model) 조작 등을 활용하는 방식으로, 웹 페이지의 일부분만 고쳐쓸 수 있는 비동기 통신 방법이다. 기존의 동기식 통신에 비해서 페이지의 일부분만 갱신되기 때문에 리스폰스로 전송되는 데이터 양은 줄어든다는 장점이 있다. 그러나 실시간으로 서버에서 정보를 취득하려고 하면 대량의 리퀘스트가 발생한다는 문제가 있다.

**Comet에 의한 해결 방법**  
Comet은 서버 측의 콘텐츠에 갱신이 있었을 경우 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법이다. 응답을 연장시킴으로써 서버에서 통신을 개시하는 서버 푸시 기능을 유사하게 따르고 있다. 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해서 커넥션을 유지하는 시간이 길어진다.

#### 9.2.2 SPDY 설계와 기능
SPDY는 HTTP를 완전히 바꿔 놓는 것이 아니라 TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작한다. 또한, SPDY는 보안을 위해 표준으로 SSL을 사용하도록 되어 있다.

SPDY를 사용하면 다음과 같은 기능을 HTTP에 추가할 수 있다.  
- 다중화 스트림 : 단일 TCP 접속을 통해 복수의 HTTP 리퀘스트를 무제한으로 처리할 수 있다.
- 리퀘스트의 우선 순위 부여 : SPDY는 무제한으로 리퀘스트를 병렬 처리할 수 있지만, 각 리퀘스트에 우선 순위를 할당할 수 있다.
- HTTP 헤더 압축 : 리퀘스트와 리스폰스의 HTTP 헤더를 압축한다.
- 서버 푸시 기능 : 서버에서 클라이언트로 데이터를 푸쉬하는 서버 푸시 기능을 지원한다.
- 서버 힌트 기능 : 서버가 클라이언트에게 리퀘스트 해야 할 리소스를 제안할 수 있다.

#### 9.2.3 SPDY는 웹의 병목 현상을 해결하는가?
SPDY는 기본적으로 한 개의 도메인과의 통신을 다중화할 뿐이기 때문에 하나의 웹 사이트에서 복수의 도메인으로 리소스를 사용하고 있는 경우에는 그 효과가 한정적이게 된다. SPDY는 HTTP의 병목 현상을 해결하는 좋은 기술이지만, 대부분의 웹 사이트의 문제는 HTTP의 병목 현상 때문만은 아니다.

### 9.3 브라우저에서 양방향 통신을 하는 WebSocket
WebSocket은 새로운 프로토콜과 API에 의해 이 문제를 해결하기 위한 기술로서 개발되었다.

#### 9.3.1 WebSocket의 설계와 기능
WebSocket은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격으로, 주로 Ajax나 Comet에서 사용하는 XMLHttpRequest의 결점을 해결하기 위한 기술로서 개발되고 있다.

#### 9.3.2 WebSocket 프로토콜
WebSocket은 웹 서버와 클라이언트가 한 번 접속을 확립하면 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식으로 JSON이나 XML, HTML이나 이미지 등 임의 형식의 데이터를 보내게 된다.

WebSocket 프로토콜의 주요 특징은 다음과 같다.
- 서버 푸시 기능 : 서버는 클라이언트의 리퀘스트를 기다리지 않고 데이터를 보낼 수 있다.
- 통신량의 삭감 : WebSocket으로 통신을 하려면 한 번 HTTP에 접속을 확립하고 핸드쉐이크 절차를 밟을 필요가 있다.

### 9.4 등장이 기다려지는 HTTP/2.0
**HTTP/2.0의 특징**  
- SPDY
- HTTP Speed + Mobility
- Network-Friendly HTTP Upgrade

**HTTP/2.0에서 논의되는 7가지 기술**  
- 다중화 (SPDY)
- TLS의 의무화 (Speed + Mobility)
- 네고시에이션 (Speed + Mobility 또는 Friendly)
- 클라이언트 풀/서버 무시 (Speed + Mobility)
- 흐름 제어 (SPDY)
- WebSocket (Speed + Mobility)

### 9.5 웹 서버 상의 파일을 관리하는 WebDAV
WebDAV(Web-based Distribued Authoring and Versioning)는 웹 서버의 콘텐츠에 대해서, 직접 파일 복사나 편집 작업 등을 할 수 있는 분산 파일 시스템이다. 파일 작성이나 삭제 등 기본적이 기능 이외에 파일 작성자 등의 관리나 편집중에 다른 유저가 다시 고쳐 쓰지 못하도록 잠금 기능, 갱신 정보를 관리하는 리비전 기능 등이 준비되어 있다.

#### 9.5.1 HTTP/1.1을 확장한 WebDAV
- 컬렉션(Collection) : 여러 개의 리소스를 한꺼번에 관리하기 위한 개념이다. 각종 조작은 컬렉션 단위로 할 수 있고, 컬렉션 속에 컬렉션을 두어 사용할 수도 있다.
- 자원(Resource) : 파일이나 컬렉션을 리소스라고 부른다.
- 프로퍼티(Property) : 리소스의 프로퍼티를 정의한 것이다. 정의는 "이름=값"의 형식으로 이루어진다.
- 잠금(Lock) : 파일을 편집할 수 없는 상태로 한다. 여러 명의 사람이 동시에 편집하는 경우 등 동시에 작성되는 걸 예방한다.

#### 9.5.2 WebDAV에서 추가된 메소드와 상태 코드
- PROPFIND : 프로퍼티 취득
- PROPPATCH : 프로퍼티 변경
- MKCOL : 컬렉션 작성
- COPY : 리소스 및 프로퍼티 복제
- MOVE : 리소스 이동
- LOCK : 리소스 잠금
- UNLOCK : 리소스 잠금 해제

메소드의 확장에 맞춰 상태 코드도 확장되었다.
- 102 Processing : 리퀘스트는 정상적으로 수신되었지만 아직 처리중이다.
- 207 Multi-Status : 복수의 스테이터스를 가지고 있다.
- 422 Unprocessable Entity : 서식은 올바르지만 내용이 틀리다.
- 423 Locked : 리소스가 잠겨있다.
- 424 Failed Dependency : 어떤 리퀘스트와 관련된 리퀘스트가 실패했기 때문에 의존 관계를 유지 못한다.
- 507 Insufficient Storage : 기억 영역이 부족하다.

## 제10장. 웹 콘텐츠에서 사용하는 기술
### 10.1 HTML
#### 10.1.1 웹 페이지의 대부분은 HTML로 되어 있다
**HTML(HyperText Markup Language)** 은 웹 상에서 하이퍼텍스트를 보내기 위해 개발된 언어이다. 하이퍼텍스트는 문서 시스템의 하나로서 문서 중에 임의의 장소의 정보가 다른 정보에 관련된 즉, 링크되어 있는 문서이다. 마크업 언어는 문서의 일부에 특별한 문자열을 붙임으로써 문서를 수식하는 언어이다. HTML로 쓰여진 문서는 브라우저가 해석하여 렌더링(Rendering) 처리 한 결과를 웹 페이지에 표시한다.

#### 10.1.2 HTML 버전
팀 버너스 리가 HTTP를 발표했을 때 HTML의 원형도 제창되었다. 1993년에 모자이크라는 브라우저가 발표되는데, 모자이크가 해석할 수 있는 HTML의 사양을 정리한 것이 HTML 1.0으로 공개되었다. 1999년 12월에는 4.01이, 다음 버전인 HTML5는 2014년 정식으로 권고안이 발표되었다.

#### 10.1.3 디자인을 적용하는 CSS
**CSS(Cascading Style Sheets)** 는 HTML 각 요소를 어떻게 표시할지를 지시하는 것으로, 스타일 시트라고 불리는 사양중의 하나이다. 같은 HTML 문서라도 적용시킬 CSS를 바꾸면 브라우저에서 보이는 외관을 변경할 수 있다.

### 10.2 다이나믹 HTML
#### 10.2.1 웹 페이지를 동적으로 변경하는 다이나믹 HTML
다이나믹 HTML은 정적인 HTML 내용을 클라이언트 사이드 스크립트를 사용해서 동적으로 변경하는 기술이다. HTML 등으로 만들어진 웹 페이지를 JavaScript 등의 클라이언트 사이드 스크립트로 조작하여 동적으로 변화시킨다.

#### 10.2.2 HTML을 조작하기 쉽게 해주는 DOM
DOM은 HTML 문서와 XML 문서를 위한 API(Application Programming Interface)이다. DOM을 사용하면 HTML 내의 요소를 오브젝트로 다룰 수 있기 때문에 요소 내의 문자열을 추출하거나 CSS를 프로퍼티로서 변경해 디자인을 변경할 수 있다.

### 10.3 웹 애플리케이션
#### 10.3.1 웹을 사용해서 기능을 제공하는 웹 애플리케이션
웹 애플리케이션은 웹 기능을 사용해서 제공되는 프로그램을 지칭한다. 본래 HTTP를 사용한 웹 구조는 사전에 준비된 콘텐츠를 클라이언트의 리퀘스트에 맞게 반환하는 것인데, 웹이 보급됨에 따라 이것만으로는 부족해서 프로그램이 HTML 등의 콘텐츠를 생성할 필요가 생기게 되었다. 이러한 프로그램에 의해서 생선된 콘텐츠를 동적 콘텐츠라 부르고 사전에 준비된 콘텐츠는 정적 콘텐츠라 부르고 있다. 웹 애플리케이션은 동적 콘텐츠에 해당된다.

#### 10.3.2 웹 서버와 프로그램을 연계하는 CGI
CGI(Common Gateway Interface)는 웹 서버가 클라이언트에서 받은 리퀘스트를 프로그램에 전달하기 위한 구조이다. CGI에 의해 프로그램은 리퀘스트 내용에 맞게 HTML을 생성하는 등 동적으로 콘텐츠를 생성할 수 있다.

#### 10.3.3 Java에서 보급된 서블릿
서블릿(Servlet)은 서버 상에 HTML 등의 동적 콘텐츠를 생성하기 위한 프로그램을 가리킨다. 서블릿에서는 웹 서버와 같은 프로세스 속에서 동작하기 때문에 비교적 부하를 적게 하여 동작시킬 수 있다.

### 10.4 데이터 송신에 이용되는 포맷이나 언어
#### 10.4.1 범용적으로 사용할 수 있는 마크업 언어 XML
XML이라는 것은 목적에 맞게 확장 가능한 범용적으로 사용할 수 있는 마크업 언어이다. 인터넷을 통해 데이터 공유를 용이하게 하는 것을 목적으로 하고 있다. XML은 HTML과 같은 문서 기술 언어(SGML, Standard Generalized Markup Language)에서 파생된 것이지만 HTML에 비해서 데이터를 기술하는 것에 특화되어 있다.

#### 10.4.2 갱신 정보를 송신하는 RSS/Atom
RSS와 Atom은 뉴스나 블로그의 기사 등의 갱신 정보를 송신하기 위한 문서 포맷의 총칭으로 둘 다 XML을 이용하고 있다.

**RSS**  
- RSS 0.9 (RDF Site Summary) : 최초의 RSS로 넷프케이프 커뮤니케이션사가 자사의 포털 사이트를 위해서 1999년 3월에 개발하였으며 RDF 구문이 사용되고 있다.
- RSS 0.91 (Rich Site Summary) : RSS 0.9에 요소를 확장할 목적으로 1999년 7월에 개발되었으며 RDF 구문이 아닌 독자적인 XML로 기술되어 있다.
- RSS 1.0 (RDF Site Summary) : RSS 규격이 혼란한 중에 2000년 12월에 RSS-DEV 워킹 그룹에 의해서 다시금 RSS 0.9에서 사용되었던 RDF 구문이 채용되었다.
- RSS 2.0 (Really Simple Syndication) : RSS 1.0 노선과는 별도로 RSS 0.91과 호환성을 유지하기 위해 2000년 12월에 유저랜드 소프트웨어사가 개발했다.

**Atom**  
- Atom 전송 포맷(Atom Syndication Format) : 콘텐츠를 전송하기 위한 피드의 포맷으로 단순이 Atom이라고 한 경우 이걸 가리킨다.
- Atom 출판 프로토콜(Atom Publishing Protocol) : 웹 상의 콘텐츠를 편집하기 위한 프로토콜이다.

## 제11장. 웹 공격 기술
### 11.1 웹 공격 기술
#### 11.1.1 HTTP에는 보안 기능이 없다
HTTP는 구조가 단순한 프로토콜이다. 원격 접속으로 사용하는 SSH라는 프로토콜에는 프로토콜 레벨에서 인증이나 세션 관리 등의 기능이 준비되어 있지만 HTTP에는 없다. 또한 SSH 서비스 셋업은 누구나 안전한 레벨까지 쉽게 구축할 수 있지만 HTTP에서는 웹 서버가 설치되었다고 하더라도 웹 애플리케이션의 대부분은 처음부터 개발하기 때문에 보안 등급이 충분치 못하고 공격자가 악용할 수 있는 취약성과 같은 버그가 있는 상태로 가동되고 있는 웹 애플리케이션이 있다.

#### 11.1.2 리퀘스트는 클라이언트에서 변조 가능
웹 애플리케이션이 브라우저로부터 수신한 HTTP 리퀘스트의 내용은 모든 클라이언트에서 자유롭게 변경하고 변조할 수 있기 때문에 정보를 도둑맞거나 권한을 빼앗기는 일이 발생할 수 있다.

#### 11.1.3 웹 애플리케이션에 대한 공격 패턴
**서버를 노리는 능동적 공격**  
능동적 공격(active attack)은 공격자가 직접 웹 애플리케이션에 액세스해서 공격 코드를 보내는 타입의 공격이다. 이 타입의 공격은 서버 상의 리소스에 대해 직접 실행되기 때문에 공격자가 리소스에 액세스 할 필요가 있다. SQL 인젝션과 OS 커맨드 인젝션 등이 있다.

**유저를 노리는 수동적 공격**  
수동적 공격(passive attack)은 함정을 이용해서 유저에게 공격 코드를 실행시키는 공격이다. 공격자는 함정을 설치하고 유저를 유도한다. 유저가 함정에 걸리면 공격 코드를 포함한 HTTP 리퀘스트를 웹 애플리케이션에 송신한다. 공격 코드를 실행하면 유저가 가지고 있는 쿠키 등의 기밀 정보를 도둑맞거나 로그인 중인 유저의 권한이 악용되는 등의 피해가 발생한다. 크로스 사이트 스크립팅(XSS, cross-site scripting)과 크로스 사이트 리퀘스트 포저리(CSRF, Cross Site Request Forgery) 등이 있다.

### 11.2 출력 값의 이스케이프 미비로 인한 취약성
#### 11.2.1 크로스 사이트 스크립팅
크로스 사이트 스크립팅은 취약성이 있는 웹 사이트를 방문한 사용자의 브라우저에서 부정한 HTML 태그나 JavaScript 등을 동작시키는 공격이다. 크로스 사이트 스크립팅에 의해 다음과 같은 영향을 받을 수 있다.

- 가짜 입력 폼 등에 의해 유저의 개인 정보를 도둑 맞는다
- 스크립트에 의해 유저의 쿠키 값이 도둑 맞거나 피해자가 의도하지 않는 리퀘스트가 송신된다
- 가짜 문장이나 이미지 등이 표시된다

#### 11.2.2 SQL 인젝션
SQL 인젝션이란 웹 애플리케이션을 이용하고 있는 데이터베이스에 SQL을 부정하게 실행하는 공격이다. SQL 인젝션에 의해 다음과 같은 영향을 받을 수 있다.

- 데이터베이스 내의 데이터 부정 열람이나 변조
- 인증 회피
- 데이터베이스 서버를 경유한 프로그램 실행 등

#### 11.2.3 OS 커맨드 인젝션
OS 커맨드 인젝션이란 웹 애플리케이션을 경유하여 OS 명령을 부정하게 실행하는 공격이다. 웹 애플리케이션에서는 OS에서 사용되는 커맨드를 쉘을 경유해서 실행할 수 있는데 잘못된 OS 커맨드가 삽입되어 실행되어 버리는 경우가 있다.

#### 11.2.4 HTTP 헤더 인젝션
HTTP 헤더 인젝션이란 공격자가 리스폰스 헤더 필드에 개행 문자 등을 삽입함으로써 임의의 리스폰스 헤더 필드나 바디를 추가하는 수동적 공격이다. 특히 바디를 추가하는 공격을 HTTP 리스폰스 분할 공격이라고 한다. HTTP 헤더 인젝션에 의해서 다음과 같은 영향을 받을 수 있다.

- 임의의 쿠키 세트
- 임의의 URL에 리다이렉트
- 임의의 바디 표시(HTTP 리스폰스 분할 공격)

#### 11.2.5 메일 헤더 인젝션
메일 헤더 인젝션은 웹 애플리케이션의 메일 송신 기능에 공격자가 임의의 To 및 Subject 등의 메일 헤더를 부정하게 추가하는 공격이다. 취약성이 있는 웹 사이트를 이용해서 스팸 메일이나 바이러스 메일 등을 임의의 주소에 송신할 수 있다.

#### 11.2.6 디렉토리 접근 공격
디렉토리 트래버설(Directory Traversal)이란 비공개 디렉토리의 파일에 대해서 부정하게 디렉토리 패스를 가로질러 액세스하는 공격이다. 이로 인해 웹 서버 상의 파일이 잘못 열람되어 버리거나 변조 또는 삭제될 수 있다.

#### 11.2.7 리모트 파일 인클루션
리모트 파일 인클루션(Remote File Inclusion)은 스크립트의 일부를 다른 파일에서 읽어올 때 공격자가 지정한 외부 서버의 URL을 파일에서 읽게 함으로써 임의의 스크립트를 동작시키는 공격이다.

### 11.3 웹 서버의 설정이나 설계 미비로 인한 취약성
#### 11.3.1 강제 브라우징
강제 브라우징(Forced Browsing)은 웹 서버의 공개 디렉토리에 있는 파일 중에서 공개 의도가 없는 파일이 열람되게 되는 취약성이다. 강제 브라우징으로 인해 다음과 같은 영향을 받을 수 있다.

- 고객 정보 등 중요 정보 누설
- 본래 액세스 권한이 있는 사용자에게만 표시하지 않는 정보 누설
- 어디에서도 링크되지 않은 파일 누설

#### 11.3.2 부적절한 에러 메시지 처리
부적절한 에러 메시지 처리(Error Handling Vulnerability)는 공격자에게 유익한 정보가 웹 애플리케이션의 에러 메시지에 포함된다는 취약성이다. 웹 애플리케이션에 관계된 주요 에러 메시지에는 다음과 같은 것들이 있다.

- 웹 애플리케이션에 의한 에러 메시지
- 데이터베이스 등의 시스템에 의한 에러 메시지

#### 11.3.3 오픈 리다이렉트
오픈 리다이렉트(Open Redirect)는 지정한 임의의 URL로 리다이렉트 하는 기능이다. 리다이렉트 되는 곳의 URL에 악의가 있는 웹 사이트가 지정된 경우 유저가 그 웹 사이트로 유도되는 취약성과 연결된다.

### 11.4 세션 관리 미비로 인한 취약성
#### 11.4.1 세션 하이잭
세션 하이잭(Session Hijack)은 공격자가 어떠한 방법으로 유저의 세션 ID를 입수해서 악용하는 것으로, 유저로 위장하는 공격이다. 공격자가 세션 ID를 입수하는 방법에는 주로 다음과 같은 것들이 있다.

- 부적절한 생성 방법에 의한 세션 ID 추측
- 도청이나 XSS 등에 의한 세션 ID 도용
- 세션 고정 공격에 의한 세션 ID 강제

#### 11.4.2 세션 픽세이션
세션 픽세이션(Session Fixation)은 공격자가 지정한 세션 ID를 유저에게 강제적으로 사용하게 하는 공격으로 수동적 공격이다.

#### 11.4.3 크로스 사이트 리퀘스트 포저리
크로스 사이트 리퀘스트 포저리는 인증된 유저가 의도하지 않는 개인 정보나 설정 정보 등을 공격자가 설치해 둔 함정에 의해 어떤 상태를 갱신하는 처리를 강제로 실행시키는 공격으로 수동적 공격이다. 크로스 사이트 리퀘스트 포저리에 의해 다음과 같은 영향을 받을 수 있다.

- 인증된 유저의 권한으로 설정 정보 등을 갱신
- 인증된 유저의 권한으로 상품을 구입
- 인증된 유저의 권한으로 게시판에 글 작성

### 11.5 기타
#### 11.5.1 패스워드 크래킹
패스워드 크래킹(Password Cracking)은 패스워드를 논리적으로 이끌어내서 인증을 돌파하는 공격이다. 패스워드 크래킹에는 다음과 같은 방법들이 있다.

- 네트워크 경유로 패스워드 시행 : 무차별 대입 공격(Brute-force Attack)과 사전 공격(Dictionary Attack)이 있다.
- 암호화 된 패스워드를 해독(공격자가 시스템에 침입하는 방법 등을 통해서 암호화나 해시화 된 패스워드의 데이터를 취득한 상황) : 무차별 대입 공격/사전 공격에 의한 유추, 레인보우 테이블, 열쇠 압수, 암호 알고리즘의 취약성 등의 방법이 있다.

#### 11.5.2 클릭 재킹
클릭 재킹(Click Jacking)은 투명한 버튼이나 링크를 함정으로 사용할 웹 페이지에 심어 두고 유저에게 링크를 클릭하게 함으로써 의도하지 않은 콘텐츠에 액세스 시키는 공격이다.

#### 11.5.3 DoS 공격
DoS 공격(Denial of Service attack)은 서비스 제공을 정지 상태로 만드는 공격이다. DoS 공격에는 다음과 같은 방법들이 있다.

- 액세스를 집중시킴으로써 부하를 걸어 리소스를 다 소비하게 해 사실상 서비스를 정지 상태로 만든다
- 취약성을 공격해 서비스를 정지시킨다

#### 11.5.4 백도어
백도어(Backdoor)는 제한된 기능을 정규 절차를 밟지 않고 이용하기 위해 설치된 뒷문이다. 주요 백도어에는 다음과 같은 종류가 있다.

- 개발 단계에 디버그용으로 추가한 백도어
- 개발자가 자기 자신의 이익을 위해서 추가한 백도어
- 공격자가 어떠한 방법을 써서 설치한 백도어
