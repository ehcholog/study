## 목차
1. [웹과 네트워크의 기본에 대해 알아보자](#제1장-웹과-네트워크의-기본에-대해-알아보자)
2. [간단한 프로토콜 HTTP](#제2장-간단한-프로토콜-http)
3. [HTTP 정보는 HTTP 메시지에 있다](#제3장-http-정보는-http-메시지에-있다)
4. [결과를 전달하는 HTTP 상태 코드](#제4장-결과를-전달하는-http-상태-코드)
5. [HTTP와 연계하는 웹 서버](#제5장-http와-연계하는-웹-서버)
6. [HTTP 헤더](#제6장-http-헤더)
7. [웹을 안전하게 하는 HTTPS](#제7장-웹을-안전하게-하는-https)
8. [누가 액세스하고 있는지를 확인하는 인증](#제8장-누가-액세스하고-있는지를-확인하는-인증)
9. [HTTP에 기능을 추가한 프로토콜](#제9장-http에-기능을-추가한-프로토콜)
10. [웹 콘텐츠에서 사용하는 기술](#제10장-웹-콘텐츠에서-사용하는-기술)
11. [웹 공격 기술](#제11장-웹-공격-기술)

## 제1장. 웹과 네트워크의 기본에 대해 알아보자
### 1.1 웹은 HTTP로 나타낸다
웹 브라우저 주소 입력란에 URL을 입력했을 때 웹 페이지가 보여지는 과정 :

1. 브라우저 주소 입력란에 URL을 입력하여 어딘가에 송신
2. 어딘가에서 응답이 돌아오면 웹 페이지가 표시됨  
=> 아무것도 없는데 웹 페이지가 표시될 수는 없고, 웹 브라우저가 웹 브라우저 주소 입력란에 지정된 URL에 의지해서 웹 서버로부터 리소스라고 불리는 파일 등의 정보를 얻어서 표시하는 것. 이때 서버에 의뢰를 하는 웹 브라우저 등을 **클라이언트(Client)** 라고 부름.

클라이언트에서 서버까지 일련의 흐름을 결정하고 있는 것은 웹에서 **HTTP(HyperText Transfer Protocol)** 이라 불리는 **프로토콜**이다. 프로토콜이라는 의미는 "약속"이며, 웹은 HTTP라는 약속을 사용한 통신으로 이루어져 있다.

### 1.2 HTTP는 이렇게 태어났고 성장했다
#### 1.2.1 웹은 지식공유를 위해 고안되었다.
HTTP는 1989년 3월 CERN(유럽 입자 물리학 연구소)의 팀 버너스 리 박사가 멀리 떨어져 있는 동료 연구자와 지식을 공용하게 할 수 있도록 시스템을 고안하여 탄생하였다. 최초로 고안한 것은 여러 문서를 상호간에 관련 짓는 **하이퍼텍스트(HyperText)** 에 의해 상호간에 참조할 수 있는 **WWW(World Wide Web)** 의 기본 개념이 되는 것이었다.

WWW를 구성하는 기술로서, 문서 기술 언어로는 SGML을 베이로서 한 **HTML(HyperText Markup Language)**, 문서 전송 프로토콜로는 **HTTP**, 문서의 주소를 지정하는 방법으로 **URL(Uniform Resource Locator)** 등 세 가지가 제안되었다.

이러한 일련의 시스템(구조)의 명칭을 **WWW** 혹은 **웹(Web)** 이라 부른다.

#### 1.2.2 웹이 성장한 시대
1990년 11월 CERN에서 세계 최초의 웹 서버와 웹 브라우저가 개발되었고, 대한민국 최초의 홈페이지는 그로부터 3년 뒤인 1993년에 개발되었다.

1990년에는 HTML 1.0 초안도 검토되었지만 애매한 부분이 많았기 때문에 초안인 상태로 폐기 되었다.

1993년 1월에는 NCSA(미국 수퍼 컴퓨터 응용 연구소)에서 현재 사용하는 웹 브라우저의 선조라고 말할 수 있는 모자이크(Mosaic)를 개발했고, 같은 해 가을에 윈도우 판과 매킨토시 판도 개발되었다.

1995년에는 마이크로소프트(Microsoft) 사에서 인터넷 익스플로러(Internet Explorer) 1.0과 2.0을 출시했다. 이 무렵에 현재 웹 서버 표준의 하나인 아파치(Apache)도 Apache 0.2로 등장했다.

2004년에는 모질라 파이어폭스(Mozilla Firefox)가 출시되었고, 그 후 크롬(Chrome)과 오페라(Opera), 사파리(Safari)와 같은 브라우저들이 등장하여 점차 점유율을 늘려갔다.

#### 1.2.3 진보 안하는 HTTP
**HTTP/0.9**  
HTTP가 등장한 때는 1990년인데, 당시 정식 사양서는 아니었다. 이 당시 등장한 HTTP는 1.0 이전이라는 의미에서 HTTP/0.9로 불린다.

**HTTP/1.0**  
1996년 5월 HTTP가 정식 사양으로 공개되었다. 초기의 사양이지만 현재에서 아직 많은 서버 상에서 현역으로 가동되고 있는 프로토콜 사양이다.

**HTTP/1.1**  
1997년 1월에 공개된 HTTP/1.1 버전이 현재 가장 많이 사용되는 버전이다.

HTTP는 등장 당시 주로 텍스트를 전송하기 위한 프로토콜이었지만 여러 가지 기능이 계속 추가되어 웹이라는 틀을 넘어서 다양하게 사용되는 프로토콜이 되었다.

### 1.3 네트워크의 기본은 TCP/IP
#### 1.3.1 TCP/IP는 프로토콜의 집합
컴퓨터와 네트워크 기기가 상호간에 통신하기 위해서는 서로 같은 방법으로 통신해야 하는데 이때 필요한 규칙이 프로토콜이다. TCP/IP란 **인터넷에 관련된 다양한 프로토콜 집합의 총칭**이다.

#### 1.3.2 계층으로 관리하는 TCP/IP
TCP/IP는 '애플리케이션 계층', '트랜스포트 계층', '네트워크 계층', '링크 계층' 이렇게 4계층으로 나뉘어 있다.

프로토콜이 계층화되어 있으면 변경이 생겼을 때 해당 계층만 바꾸면 되고 설계 시 편리하다는 장점이 있다.

**애플리케이션 계층**  
유저에게 제공되는 애플리케이션에서 사용하는 통신의 움직임을 결정. FTP, DNS, HTTP 등이 있다.

**트랜스포트 계층**  
애플리케이션 계층에 네트워크로 접속되어 있는 2대의 컴퓨터 사이의 데이터 흐름을 제공. TCP(Transmission Control Protocol)와 UDP(User Data Protocol)이 있다.

**네트워크 계층**  
네트워크 상에서 패킷의 이동을 다룸. 패킷이란 전송하는 데이터의 최소 단위이며, 이 계층에서는 어떠한 경로(절차)를 거쳐 상대의 컴퓨터까지 패킷을 보낼지를 결정하기도 한다.

**링크 계층**  
네트워크에 접속하는 하드웨어적인 면을 다룸. 디바이스 드라이버랑 네트워크 인터페이스 카드(NIC)를 포함하며, 케이블과 같이 물리적으로 보이는 하드웨어적 측면은 모두 링크 계층의 역할이다.

#### 1.3.3 TCP/IP 통신의 흐름
TCP/IP로 통신을 할 때에는 계층을 순서대로 거쳐 통신을 한다. 송신하는 측은 애플리케이션 계층에서부터 내려가고, 수신하는 측은 애플리케이션 계층으로 올라간다.

클라이언트 : HTTP 클라이언트(애플리케이션 계층) -> TCP(트랜스포트 계층) -> IP(네트워크 계층) -> 네트워크(링크 계층)  
서버 : 네트워크(링크 계층) -> IP(네트워크 계층) -> TCP(트랜스포트 계층) -> HTTP 서버(애플리케이션 계층)

송신측에서는 각 계층을 거칠 때마다 헤더로 불려지는 정보를 추가하며, 수신측에서는 각 계층을 거칠 때마다 해당 계층의 헤더를 삭제한다. 이렇게 정보를 감싸는 것을 **캡슐화**라고 한다.

### 1.4 HTTP와 관계가 깊은 프로토콜은 IP/TCP/DNS
#### 1.4.1 배송을 담당하는 IP
IP는 개개의 패킷을 상대방에게 전달한다. 상대방에게 전달하려면 여러 요소가 필요한데, 그 중에는 IP 주소와 MAC 주소가 있다. IP 주소는 각 노드에 부여된 주소를 가리키고 MAC 주소는 각 네트워크 카드에 할당된 고유의 주소이며, IP 주소는 변경 가능하지만 MAC 주소는 변경할 수 없다.

IP 통신은 MAC 주소에 의존해서 통신하는데, 이때 ARP(Address Resolution Protocol)이라는 프로토콜이 사용된다. ARP는 주소를 해결하기 위한 프로토콜 중 하나로, 수신지의 IP 주소를 바탕으로 MAC 주소를 조사할 수 있다.

#### 1.4.2 신뢰성을 담당하는 TCP
TCP는 트랜스포트 계층으로서 신뢰성 있는 바이트 스트림 서비스를 제공한다. **바이트 스트림 서비스**란 용량이 큰 데이터를 보내기 쉽게 TCP 세그먼트라고 불리는 단위 패킷으로 작게 분해하여 관리하는 것을 말하며, 결국 TCP는 대용량의 데이터를 보내기 쉽게 작게 분해하여 상대에게 보내고, 정확하게 도착했는지 확인한다.

상대에게 확실하게 데이터를 보내기 위해서 TCP는 **쓰리웨이 핸드셰이킹(three way handshaking)** 이라는 방법을 사용한다. 이 방법은 패킷을 보내고 끝내는 것이 아니라 보내졌는지 여부를 상대에게 확인한다.

1. 송신측에서 최초 'SYN' 플래그로 상대에게 접속함과 동시에 패킷을 보냄.
2. 수신측에서 'SYN/ACK' 플래그로 송신측에 접속함과 동시에 패킷을 수신한 사실을 전함.
3. 마지막으로 송신측이 'ACK' 플래그를 보내 패킷 교환이 완료되었음을 전함.

이 과정에서 어디선가 통신이 도중에 끊어지면 TCP는 그와 동시에 같은 수순으로 패킷을 재전송한다.

### 1.5 이름 해결을 담당하는 DNS
DNS(Domain Name System)는 HTTP와 같이 응용 시스템에서 도메인 이름과 IP 주소 이름 확인을 제공한다. 사람에게 친숙한 도메인명에서 숫자로 되어있는 IP 주소를 조사하거나 반대로 IP 주소로부터 도메인명을 조사하는 서비스를 제공하고 있다.

### 1.6 각각과 HTTP와의 관계
1. 클라이언트가 DNS에 도메인명으로 요청한 IP 주소를 제공 받음.
2. HTTP 담당 : 웹 서버에 보낼 HTTP 메시지 작성.
3. TCP 담당 : 통신하기 쉽도록 HTTP 메시지를 패킷으로 분해.
4. IP 담당 : 상대가 어디에 있는지 찾아 중계해 가면서 배송.
5. TCP 담당 : 상대방으로부터 패킷을 수신.
6. HTTP 담당 : 웹 서버에 대한 리퀘스트 내용을 처리.
7. 서버에서 처리 결과를 마찬가지로 TCP/IP 통신 순서대로 클라이언트에 반환.

### 1.7 URI와 URL
#### 1.7.1 URI는 리소스 식별자
**URI(Uniform Resource Identifiers)**  
**Uniform** : 통일된 서식을 결정하는 것으로, 여러 가지 종류의 리소스 지정 방법을 같은 맥락에서 구별없이 취급할 수 있게 한다. 또한, 새로운 스키마(http: 와 ftp 등) 도입을 용이하게 한다.

**Resource** : '식별 가능한 모든 것'으로서 도큐먼트 파일뿐만 아니라 이미지와 서비스 등 다른 것과 구별할 수 있는 것은 모두 리소스이다. 리소스는 단일한 부분만 아니라 복수의 집합도 리소스로 파악할 수 있다.

**Identifier** : 식별 가능한 것을 참조하는 오브젝트이며 식별자로 불린다. 결국, URI는 스키마를 나타내는 리소스를 식별하기 위한 식별자이다. **스키마**는 리소스를 얻기 위한 수단에 이름을 붙이는 방법이다.

#### 1.7.2 URL 포맷
URI는 필요한 정보 전체를 지정하는 완전 수식 절대 URI 혹은 완전 수식 절대 URL과 브라우저 중의 기준 URI에서 상대적 위치를 지정하는 상대 URI이 있다.

http://user:pass@www.example.jp:80/dir/index.htm?uid=1#ch1

스키마 : http://  
자격정보(크리덴셜) : user:pass  
서버주소 : www.example.jp  
서버포트 : 80  
계층적 파일 패스 : dir/index.html  
쿼리 문자열 : uid=1  
프래그먼트 식별자 : ch1

## 제2장. 간단한 프로토콜 HTTP
### 2.1 HTTP는 클라이언트와 서버 간에 통신을 한다
TCP/IP에 있는 다른 많은 프로토콜과 마찬가지로 HTTP도 클라이언트와 서버 간에 통신을 한다. 리소스를 요구하는 쪽이 **클라이언트**가 되고, 리소스를 제공하는 쪽이 **서버**가 된다.

### 2.2 리퀘스트와 리스폰스를 교환하여 성립
HTTP는 클라이언트로부터 리퀘스트(요청, Request)가 송신되며, 그 결과가 서버로부터 리스폰스(응답, Response)로 되돌아온다.  

리퀘스트는 다음과 같이 구성된다.

GET /index.html  
HTTP /1.1  Host: www.hackr.jp

"GET"은 서버에 요구하는 종류를 나타내며 메소드라고 불린다. "/index.html"은 요구 대상인 리소스이며 리퀘스트 URI라고 한다. "HTTP /1.1"은 클라이언트 기능을 식별하기 위한 HTTP 버전 번호이다.

리스폰스는 다음과 같이 구성된다.

HTTP /1.1 200 OK  
Date: Tue, 10 Jul 2012 06:50:15 GMT  
Content-Length: 362  
Content-Type: text/html  

html  
...

첫번째 줄에는 리퀘스트와 같이 서버의 HTTP 버전을 나타내고 있고, "200 OK"는 리퀘스트의 처리 결과를 나타내는 상태 코드와 설명이다. 다음 줄은 리스폰스가 발생한 일시를 나타내는 헤더 필드의 정보들이 있다. 그리고 빈 줄로 구분한 아래 부분에 있는 부분이 바디(body)라고 불리는 리소스 본체이다.

### 2.3 HTTP는 상태를 유지하지 않는 프로토콜
HTTP는 상태를 계속 유지하지 않는 스테이트리스(stateless) 프로토콜이다. 즉, HTTP 프로토콜 레벨에서는 이전에 보냈던 리퀘스트나 이미 되돌려준 리스폰스에 대해 기억하지 않는다. 이는 많은 데이터를 빠르고 확실하게 처리하는 범위성(scalability)을 확보하기 위함이다. 상태를 계속 유지하기 위한 기술로는 **쿠키(Cookie)** 가 있다.

### 2.4 리퀘스트 URI로 리소스를 식별
클라이언트는 리소스를 호출할 때마다 리퀘스트를 송신할 때 리퀘스트 URI라고 불리는 형식을 포함해야 할 필요가 있다. 리퀘스트 URI를 지정하는 방법에는 여러 종류가 있다.
1. 모든 URI를 리퀘스트 URI에 포함한다. 예) GEP http://hackr.jp/index.html HTTP/ 1.1
2. Host 헤더 필드에 네트워크 로케이션을 포함한다. 예) GET /index.html HTTP/ 1.1 Host: hackr.jp

특정 리소스가 아닌 서버 자신에게 리퀘스트를 송신하는 경우에는 리퀘스트 URI에 [*]을 지정할 수 있다. 예) OPTIONS * HTTP/1.1

### 2.5 서버에 임무를 부여하는 HTTP 메소드
**GET : 리소스 획득**  
GET 메소드는 리퀘스트 URI로 식별된 리소스를 가져올 수 있도록 요구한다. 가져올 리소스 내용은 지정된 리소스를 서버가 해석한 결과이다.

**POST : 엔티티 전송**  
GET으로도 엔티티를 전송할 수 있지만, 일반적으로는 POST를 사용한다.

**PUT : 파일 전송**  
PUT 메소드는 파일을 전송하기 위해서 사용된다. FTP에 의한 파일 업로드와 같이, 리퀘스트 중에 포함된 엔티티를 리퀘스트 URI로 지정한 곳에 보존하도록 요구한다. 그러나 HTTP/1.1 PUT 자체에는 인증 기능이 없어 누구든지 파일을 업로드 가능하다는 보안 상의 문제도 있어서 일반적인 웹 사이트에서는 사용되지 않고 있다. 웹 애플리케이션 등에 의한 인증 기능과 짝을 이루는 경우나 RESP(Representational State Transfer)와 같이 웹끼리 연계하는 설계 양식을 사용할 때 이용하는 경우가 있다.

**HEAD : 메시지 헤더 획득**  
GET과 같은 기능이지만 메시지 바디는 돌려주지 않는다. URI 유효성과 리소스 갱신 시간을 확인하는 목적 등으로 사용된다.

**DELETE : 파일 삭제**  
DELETE 메소드는 PUT 메소드와는 반대로 동작하며 리퀘스트 URI로 지정된 리소스의 삭제를 요구한다. PUT 메소드와 마찬가지로 HTTP /1.1의 DELETE 자체에는 인증 기능이 없기 때문에 PUT과 비슷한 경우에 사용된다.

**OPTIONS : 제공하고 있는 메소드의 문의**  
OPTIONS 메소드는 리퀘스트 URI로 지정한 리소스가 제공하고 있는 메소드를 조사하기 위해 사용된다.

**TRACE : 경로 조사**  
TRACE 메소드는 Web 서버에 접속해서 자신에게 통신을 되돌려 받는 루프백(loop-back)을 발생시킨다. 클라이언트는 TRACE 메소드를 사용함으로써, 리퀘스트를 보낸 곳에 어떤 리퀘스트가 가공되어 있는지 등을 조사할 수 있다. TRACE 메소드는 크로스 사이트 트레이싱(XST)과 같은 공격을 일으키는 보안 상의 문제도 있기 때문에 보통은 사용되지 않는다.

**CONNECT : 프록시에 터널링 요구**  
CONNECT 메소드는 프록시에 터널 접속 확립을 요함으로써, TCP 통신을 터널링 시키기 위해서 사용된다. 주로 SSL이랑 TLS 등의 프로토콜로 암호화 된 것을 터널링 시키기 위해서 사용되고 있다.

### 2.6 메소드를 사용해서 지시를 내리다
리퀘스트 URI로 지정한 리소스에 리퀘스트를 보내는 경우에는 메소드라고 불리는 명령이 있다. 메소드는 리소스에 어떠한 행동을 하기 원하는지를 지시하기 위해 존재하며, GET과 POST, HEAD 등이 있다. 메소드는 대문자와 소문자를 구별하기 때문에 대문자로 기재할 필요가 있다.

### 2.7 지속 연결로 접속량을 절약
#### 2.7.1 지속 연결
HTTP/1.1과 일부 HTTP/1.0에서는 TCP 연결 문제를 해결하기 위해 **지속 연결(Persistent Connections)** 이라는 방법을 고안하였다. 지속 연결의 특징은 어느 한 쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다는 것이다. 지속 연결의 이점은 TCP 커넥션의 연결과 종료의 반복되는 오버헤드를 줄여주기 때문에 서버에 대한 부하가 경감되고, 오버헤드를 줄인 만큼 HTTP 통신이 빠르게 완료되기 때문에 웹 페이지를 빨리 표시할 수 있다.

#### 2.7.2 파이프라인화
지속 연결은 여러 리퀘스트를 보낼 수 있도록 **파이프라인(HTTP pipelining)화**를 가능하게 한다. 이전에는 리퀘스트 송신 후에 리스폰스를 수신할 때까지 기다린 뒤에 리퀘스트를 발행하던 것을, 리스폰스를 기다리지 않고 바로 다음 리퀘스트를 보낼 수 있다.

### 2.8 쿠키를 이용한 상태 관리
HTTP는 스테이트리스(stateless) 프로토콜이기 때문에 과거에 교환했었던 리퀘스트와 리스폰스의 상태를 관리하지 않는다. 예를 들면, 인증한 웹 페이지에서 상태 관리를 하지 않는다면 새로운 페이지로 이동할 때마다 매번 인증을 해야 한다. 이러한 문제를 해결하기 위한 것이 쿠키이다.

쿠키는 서버에서 리스폰스로 보내진 Set-Cookie라는 헤더 필드에 의해 클라이언트에 보존하게 된다. 다음 번에 클라이언트가 같은 서버로 리퀘스트를 보낼 때, 자동으로 쿠키 값을 넣어서 송신하면 서버는 클라이언트가 보내온 쿠키를 확인해 어느 클라이언트가 접속했는지 체크해서 이전 상태를 알 수 있다.

## 제3장. HTTP 정보는 HTTP 메시지에 있다

## 제4장. 결과를 전달하는 HTTP 상태 코드

## 제5장. HTTP와 연계하는 웹 서버

## 제6장. HTTP 헤더

## 제7장. 웹을 안전하게 하는 HTTPS

## 제8장. 누가 액세스하고 있는지를 확인하는 인증

## 제9장. HTTP에 기능을 추가한 프로토콜

## 제10장. 웹 콘텐츠에서 사용하는 기술

## 제11장. 웹 공격 기술
