# HTTP
## HTTP란?
- HTTP는 HyperText Transfer Protocol의 줄임말로 WWW 상에서 사용하는 프로토콜이다.
- 1990년대 팀 버너스 리가 월드 와이드 웹을 만들어서 하이퍼텍스트 문서들을 주고 받기 위한 규약으로 만든 것이 HTTP이다.
- 현재에는 문서들 뿐만 아니라 이미지, 비디오, 음성 등 거의 모든 형식의 데이터를 전송하는데 사용되고 있다.
- HTTP는 서버와 클라이언트 사이에 요청과 응답을 주고 받는 프로토콜로 우리가 흔히 웹 브라우저 주소창에 입력하는 웹 주소인 URL을 통해 요청과 응답이 이루어진다.
- 실제 전송은 TCP를 통해 이루어지며 포트는 80번을 이용한다.

## HTTP 메시지 구조
- HTTP 메시지는 ASCII로 인코딩 된 텍스트로 되어 있다.
- 기본적인 구조는 다음과 같다.
![image](https://github.com/ehcholog/study/assets/135564811/ec806dd2-25b3-4de9-a5e0-591b47182892)
- HTTP 메시지는 기본적으로 클라이언트가 요청하고 서버가 응답하는 구조이기 때문에 메시지는 요청이냐 응답이냐에 따라 각 메시지의 구성 내용이 달라진다.
![image](https://github.com/ehcholog/study/assets/135564811/25cc4f48-09cf-4e57-b083-302fe81fcb19)

## HTTP 메서드
- HTTP 메서드는 클라이언트가 서버에 요청의 목적 및 종류를 알리는 수단이다.
- HTTP 요청 시에 메시지 시작줄에 표시된다.
- Restful API 구조 등이 많이 사용되기 때문에 주로 GET, POST, PUT, DELETE 정도의 메서드 위주로 알아두면 좋다.
![image](https://github.com/ehcholog/study/assets/135564811/ed1d4040-68bd-4809-8579-66dcc66d4402)

## HTTP 헤더
- HTTP 메시지 구조를 보면 HTTP 헤더가 들어가는데 요청/응답 헤더, general 헤더, entity 헤더로 구분된다.
- 헤더는 기본적으로 key : value 방식으로 표기되며, 헤더 안에 들어갈 수 있는 종류는 매우 많다.
- 하지만 주로 많이 사용되는 헤더들을 정리해 보자면 다음과 같다.

### 요청(request) 헤더
![image](https://github.com/ehcholog/study/assets/135564811/315ff77f-cc00-4f84-9475-521342a156fe)

### 응답(response) 헤더
![image](https://github.com/ehcholog/study/assets/135564811/1a49c01a-79dd-47fb-954e-6b6c68571dbc)

### general 헤더
![image](https://github.com/ehcholog/study/assets/135564811/a0f6b1c1-18c6-4f4f-867a-e7bf04c7e201)

### entity 헤더 (body가 없는 경우 전송되지 않음)
![image](https://github.com/ehcholog/study/assets/135564811/fefb8ceb-3d52-456c-af21-8cdbfb12dbd8)

## HTTP 상태코드
- HTTP 상태코드는 응답 메시지 중에서도 start-line에 표기된다.
- HTTP 상태코드는 요청에 대한 처리 결과를 알려준다.
- HTTP 상태코드는 3자리 숫자로 표현하는데 100대부터 500대까지 있다.
- HTTP 상태코드 별 값과 의미가 다양하지만 각 번호대의 대략적인 의미는 다음과 같다.
```
- 1xx : 정보성
- 2xx : 성공
- 3xx : 리다이렉션
- 4xx : 클라이언트 오류
- 5xx : 서버 오류
```

*참고 : https://noahlogs.tistory.com/34

# GET과 POST
## GET이란?
- GET은 클라이언트에서 서버로 어떠한 리소스로부터 정보를 요청하기 위해 사용되는 메서드이다.
- GET을 통한 요청을 URL 주소 끝에 파라미터로 포함되어 전송되며, 이 부분을 **쿼리 스트링(Query String)** 이라고 부른다.
- 방식은 URL 끝에 "?"를 붙이고 그 다음 "변수명1=값1&변수명2=값2..." 형식으로 이어 붙인다.  
``예) www.example.com/show?name=value1&name2=value2``

## GET의 특징
- GET 요청은 캐시가 가능하다. GET을 통해 서버에 리소스를 요청할 때 웹 캐시가 요청을 가로채 서버로부터 리소스를 다시 다운로드 하는 대신 리소스의 복사본을 반환한다. HTTP 헤더에서 cache-control 헤더를 통해 캐시 옵션을 지정할 수 있다.
- GET 요청은 브라우저 히스토리에 남는다.
- GET 요청은 북마크 될 수 있다.
- GET 요청은 길이 제한이 있다. GET 요청의 길이 제한은 표준이 따로 있는건 아니고 브라우저마다 제한이 다르다고 한다.
- GET 요청은 파라미터에 정보가 다 노출되기 때문에 보안상 중요한 정보를 다루면 안된다.
- GET 요청은 데이터를 요청할 때만 사용된다.

## POST란?
- POST는 클라이언트에서 서버로 리소스를 생성하거나 업데이트하기 위해 데이터를 보낼 때 사용되는 메서드이다.
- POST는 전송할 데이터를 HTTP 메시지 body 부분에 담아서 서버로 보낸다. (body의 타입은 Content-Type 헤더에 따라 결정된다.)
- GET에서 URL의 파라미터로 보냈던 "name1=value1&name2=value2..."가 body에 담겨 보내진다고 보면 된다.
- POST로 데이터를 전송할 때 길이 제한이 따로 없어 용량이 큰 데이터를 보낼 때 사용하거나 GET처럼 데이터가 외부적으로 드러나는건 아니라서 보안이 필요한 부분에 많이 사용된다.
- 하지만 데이터를 암호화하지 않으면 body의 데이터도 결국 볼 수 있는건 똑같다.

## POST의 특징
- POST 요청은 캐시되지 않는다.
- POST 요청은 브라우저 히스토리에 남지 않는다.
- POST 요청은 북마크되지 않는다.
- POST 요청은 데이터 길이에 제한이 없다.

## GET과 POST의 차이점
- 사용목적 : GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트 할 때 사용한다. DB로 따지면 GET은 SELECT에 가깝고 POST는 CREATE에 가깝다고 보면 된다.
- 요청에 body 유무 : GET은 URL 파라미터에 요청하는 데이터를 담아 보내기 때문에 HTTP 메시지에 body가 없다. POST는 body에 데이터를 담아 보내기 때문에 당연히 HTTP 메시지에 body가 존재한다.
- 멱등성(Idempotent) : GET 요청은 멱등이며, POST는 멱등이 아니다.

*멱등이란?  
멱등의 사전적 정의는 연산은 여러 번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. GET은 리소스를 조회한다는 점에서 여러 번 요청하더라도 응답이 똑같을 것이다. 반대로 POST는 리소스를 새로 생성하거나 업데이트할 때 사용되기 때문에 멱등이 아니라고 볼 수 있다.

*참고 : https://noahlogs.tistory.com/34

# 쿠키(Cookie)와 세션(Session)
## 쿠키(Cookie)란?
- 쿠키(Cookie)란 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각을 의미한다.
- HTTP 통신의 stateless한 점을 보완하기 위해 만들어졌다.
- 주로 세션 관리(서버에서 관리하는 로그인 등의 정보), 개인 설정 유지, 사용자 트래킹(사용자의 행동을 기록하고 분석하는 것)의 용도로 사용된다.

## 쿠키(Cookie)의 특징
- 쿠키(Cookie)는 한 개에 4KB까지 저장 가능하며 최대 300까지 저장할 수 있는 텍스트 파일이다.
- 쿠키(Cookie)는 클라이언트에 저장된다.
- 쿠키(Cookie)에는 이름, 값, 만료날짜, 경로 정보가 들어있다.
- 기본적으로 웹 브라우저가 종료되면 삭제된다. (만료날짜를 지정할 경우 해당 날짜에 삭제된다)
- 웹 브라우저에 해당 서버의 쿠키(Cookie) 정보가 있으면 HTTP 요청에 무조건 담아 보낸다.

## 쿠키(Cookie) 작동방식
![image](https://github.com/ehcholog/study/assets/135564811/71d23355-18fd-46ad-98c9-623b702a999a)

## 세션(Session)이란?
- 세션(Session)이란 통신을 하기 위해 서로 연결된 순간부터 통신을 마칠 때까지의 기간을 의미한다.
- 클라이언트가 웹 서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때까지의 기간이다.
- 보통 세션(Session)이라 말할 때에는 서버에 세션에 대한 정보(세션 상태, 클라이언트 상태, 세션 데이터 등)를 저장해 놓고 세션 쿠키(고유한 세션 ID 값)를 클라이언트에게 주어 서버가 클라이언트를 식별할 수 있도록 하는 방식 자체를 의미하는 경우가 많다.

## 세션(Session)의 특징
- 용량의 제한이 없다. (서버의 능력에 따라 다를 수 있다)
- 서버에 세션 객체를 생성하며 각 클라이언트마다 고유한 세션 ID 값을 부여한다.
- 쿠키를 사용하여 세션 ID 값을 클라이언트에 보낸다.
- 웹 브라우저가 종료되면 세션 쿠키는 삭제된다.

## 세션(Session) 작동방식
![image](https://github.com/ehcholog/study/assets/135564811/9644aabb-a458-4076-ba11-43489f100690)

## 쿠키(Cookie)와 세션(Session)의 관계
- 흔히 쿠키와 세션을 비교할 때, 쿠키는 클라이언트(웹 브라우저)에 정보를 저장하는 것이고 세션은 서버에 정보를 저장하는 것으로 비교한다. 맞는 말이지만 서로 반대되는 개념이 아니고 결국 **세션은 쿠키를 이용하는 하나의 방식**일 뿐이다.
- 쿠키는 stateless한 HTTP 통신에서 클라이언트에게 정보를 주어 해당 클라이언트를 식별하기 위해 만들어졌다. 하지만 클라이언트에 저장된다는 쿠키의 특징은 보안이 허술하기 때문에 이것을 보완하기 위해 세션이라는 개념을 통해 중요한 정보는 서버 쪽에서 관리하도록 한 것이다.

*참고 : https://noahlogs.tistory.com/38

# OSI 7계층
1. 물리 계층 : 네트워크 케이블의 재질이나 커넥터의 형식, 핀의 나열 방법 등 물리적인 요소를 모두 규정
2. 데이터 링크 계층 : 직접 연결된 기기 사이에 논리적인 전송로(데이터 링크)를 확립하는 방법을 규정
3. 네트워크 계층 : 동일 또는 다른 네트워크의 기기와 연결하기 위한 주소와 경로의 선택 방법을 규정
4. 전송 계층 : 데이터를 통신할 상대에게 확실하게 전달하는 방법을 규정
5. 세션 계층 : 데이터를 흘려보내는 논리적인 통신로(커넥션)의 확립과 연결 끊기에 대해 규정
6. 표현 계층 : 애플리케이션 데이터를 통신에 적합한 형태로 변환하는 방법을 규정
7. 응용 계층 : 애플리케이션 별로 서비스를 제공하는 방법을 규정

![image](https://github.com/ehcholog/study/assets/135564811/371484b8-62f1-4825-a6db-12cbb6dcaafb)

# 라우팅
- 라우팅이란 라우터가 네트워크에서 패킷을 목적지까지 최적의 경로를 선택하는 과정이다.
```
*라우터란?
: 각 독립된 네트워크들을 연결할 때 L3(네트워크 계층)에서 사용하는 네트워크 기기이다. L3 장비이기 때문에 패킷을 전송한다.
```
- 라우터는 라우팅 테이블을 이용하여 패킷을 전송한다.
- 라우팅 테이블은 목적지 네트워크와 목적지 네트워크로 가기 위해 보내야 할 곳의 IP주소(넥스트 홉, Next Hop)로 구성되어 있다.
- 넥스트 홉이란 패킷이 목적지 네트워크까지 가기 위해 도달하는 다음 라우터를 의미한다.
- 패킷이 목적지까지 가는데 거치는 라우터 개수를 홉 수(Hop Count)라고 한다.
- 라우터는 패킷을 받으면 해당 패킷의 목적지 IP 주소와 라우팅 테이블의 목적지 네트워크를 대조하여 해당 IP 주소가 있으면 패킷을 전송하고 없으면 패킷을 폐기한다.

## 정적 라우팅
- 수동으로 라우팅 테이블을 만드는 방법
- 목적지 네트워크와 넥스트 홉을 하나하나 설정
- 정적 라우팅은 네트워크를 구성하는 모든 라우터에 대해 라우팅 설정이 필요
- 설정을 알기 쉽고 관리하기 쉽기 때문에 소규모 네트워크 환경에서 주로 사용

## 동적 라우팅
- 인접하는 라우터들이 라우팅 정보를 서로 교환하여 라우팅 테이블을 자동으로 만드는 방법
- 라우팅 정보를 교환하기 위한 프로토콜을 라우팅 프로토콜이라 함
- 네트워크 환경의 변화대응과 장애 내구성 향상이 가능하기 때문에 중간부터 대규모 네트워크 환경에서 주로 사용

# TCP와 UDP
## TCP(Transmission Control Protocol)
- TCP는 전송 제어 프로토콜로 IP와 함께 TCP/IP로 불리며 전송 계층에서 사용되는 프로토콜이다.
- TCP는 데이터를 송신할 때마다 확인 응답을 주고 받는 절차가 있어서 통신의 신뢰성을 높인다.
- 웹이나 메일, 파일 공유 등과 같이 데이터를 누락시키고 싶지 않은 서비스에 주로 사용된다.

## UDP(User Datagram Protocol)
- UDP는 TCP와 함께 데이터그램으로 알려진 단문 메시지를 교환하기 위해 사용하는 프로토콜이다.
- 데이터만 보내고 확인 응답과 같은 절차를 생략할 수 있으므로 통신의 신속성을 높인다.
- 주로 DNS, VoIP 등에 사용된다.

*참고 : https://noahlogs.tistory.com/47
